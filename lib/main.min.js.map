{"version":3,"file":"main.min.js","sources":["../src/main.ts"],"sourcesContent":["export type HtmlStringType = HTMLElement | Node | string;\r\n\r\nexport type ExcerptOptions = { radius?: number, omission?: string }\r\n\r\nexport type Value<T> = boolean | ((instance: T) => boolean);\r\n\r\nexport type Callback<T> = (instance: T, value: boolean) => T | void | undefined;\r\n\r\nexport type Fallback<T> = Callback<T> | null;\r\n\r\nexport enum Mode {\r\n    MB_CASE_UPPER        = 0,\r\n    MB_CASE_LOWER        = 1,\r\n    MB_CASE_TITLE        = 2,\r\n    MB_CASE_FOLD         = 3,\r\n    MB_CASE_UPPER_SIMPLE = 4,\r\n    MB_CASE_LOWER_SIMPLE = 5,\r\n    MB_CASE_TITLE_SIMPLE = 6,\r\n    MB_CASE_FOLD_SIMPLE  = 7\r\n}\r\n\r\nexport class Str {\r\n    /**\r\n     * The callback that should be used to generate UUIDs.\r\n     *\r\n     * @type { Function | null }\r\n     */\r\n    protected static uuidFactory: Function | null = null;\r\n\r\n    /**\r\n     * The callback that should be used to generate ULIDs.\r\n     *\r\n     * @type { Function | null }\r\n     */\r\n    protected static ulidFactory: Function | null = null;\r\n\r\n    /**\r\n     * The callback that should be used to generate random strings.\r\n     *\r\n     * @type { Function | null }\r\n     */\r\n    protected static randomStringFactory: Function | null = null;\r\n\r\n    /**\r\n     * Get a new Stringable object from the given string.\r\n     *\r\n     * @param { string } string\r\n     */\r\n    static of(string: string): Stringable {\r\n        return new Stringable(string);\r\n    }\r\n\r\n    /**\r\n     * Return the remainder of a string after the first occurrence of a given value.\r\n     *\r\n     * @param { string } subject\r\n     * @param { string } search\r\n     *\r\n     * @return { string }\r\n     */\r\n    static after(subject: string, search: string): string {\r\n        if (search === '') {\r\n            return subject;\r\n        }\r\n\r\n        return subject.slice(subject.indexOf(search) + search.length);\r\n    }\r\n\r\n    /**\r\n     * Return the remainder of a string after the last occurrence of a given value.\r\n     *\r\n     * @param { string } subject\r\n     * @param { string } search\r\n     *\r\n     * @return { string }\r\n     */\r\n    static afterLast(subject: string, search: string): string {\r\n        if (search === '') {\r\n            return subject;\r\n        }\r\n\r\n        const position: number = subject.lastIndexOf(search);\r\n\r\n        if (position === -1) {\r\n            return subject;\r\n        }\r\n\r\n        return subject.substring(position + search.length);\r\n    }\r\n\r\n    /**\r\n     * Transliterate a UTF-8 value to ASCII.\r\n     *\r\n     * @param { string } value\r\n     *\r\n     * @return { string }\r\n     */\r\n    static ascii(value: string): string {\r\n        return value.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '');\r\n    }\r\n\r\n    /**\r\n     * Get the portion of a string before the first occurrence of a given value.\r\n     *\r\n     * @param { string } subject\r\n     * @param { string } search\r\n     *\r\n     * @return { string }\r\n     */\r\n    static before(subject: string, search: string): string {\r\n        if (search === '') {\r\n            return subject;\r\n        }\r\n\r\n        const result: string = subject.substring(0, subject.indexOf(search));\r\n\r\n        if (result === '') {\r\n            return subject;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get the portion of a string before the last occurrence of a given value.\r\n     *\r\n     * @param { string } subject\r\n     * @param { string } search\r\n     *\r\n     * @return { string }\r\n     */\r\n    static beforeLast(subject: string, search: string): string {\r\n        if (search === '') {\r\n            return subject;\r\n        }\r\n\r\n        const position: number = subject.lastIndexOf(search);\r\n\r\n        if (position === -1) {\r\n            return subject;\r\n        }\r\n\r\n        return this.substr(subject, 0, position);\r\n    }\r\n\r\n    /**\r\n     * Get the portion of a string between two given values.\r\n     *\r\n     * @param { string } subject\r\n     * @param { string } from\r\n     * @param { string } to\r\n     *\r\n     * @return { string }\r\n     */\r\n    static between(subject: string, from: string, to: string): string {\r\n        if (from === '' || to === '') {\r\n            return subject;\r\n        }\r\n\r\n        return this.beforeLast(this.after(subject, from), to);\r\n    }\r\n\r\n    /**\r\n     * Get the smallest possible portion of a string between two given values.\r\n     *\r\n     * @param { string } subject\r\n     * @param { string } from\r\n     * @param { string } to\r\n     *\r\n     * @return { string }\r\n     */\r\n    static betweenFirst(subject: string, from: string, to: string): string {\r\n        if (from === '' || to === '') {\r\n            return subject;\r\n        }\r\n\r\n        return this.before(this.after(subject, from), to);\r\n    }\r\n\r\n    /**\r\n     * Convert a value to camel case.\r\n     *\r\n     * @param { string } value\r\n     *\r\n     * @return { string }\r\n     */\r\n    static camel(value: string): string {\r\n        return this.lcfirst(this.studly(value));\r\n    }\r\n\r\n    /**\r\n     * Get the character at the specified index.\r\n     *\r\n     * @param { string } subject\r\n     * @param { number } index\r\n     *\r\n     * @return { string | false }\r\n     */\r\n    static charAt(subject: string, index: number): string | false {\r\n        return subject.charAt(index);\r\n    }\r\n\r\n    /**\r\n     * Remove the given string(s) if it exists at the start of the haystack.\r\n     *\r\n     * @param { string } subject\r\n     * @param { string | string[] } needle\r\n     *\r\n     * @return string\r\n     */\r\n    static chopStart(subject: string, needle: string | string[]): string {\r\n        let results: string = subject;\r\n\r\n        needle = Array.isArray(needle) ? needle : [needle];\r\n\r\n        for (const word of needle) {\r\n            if (subject.startsWith(word)) {\r\n                results = subject.substring(word.length);\r\n            }\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Remove the given string(s) if it exists at the end of the haystack.\r\n     *\r\n     * @param { string } subject\r\n     * @param { string | string[] } needle\r\n     *\r\n     * @return string\r\n     *\r\n     */\r\n    static chopEnd(subject: string, needle: string | string[]): string {\r\n        let results: string = subject;\r\n\r\n        needle = Array.isArray(needle) ? needle : [needle];\r\n\r\n        for (const word of needle) {\r\n            if (subject.endsWith(word)) {\r\n                results = subject.substring(0, subject.length - word.length);\r\n            }\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Determine if a given string contains a given substring.\r\n     *\r\n     * @param { string } haystack\r\n     * @param { string | string[] } needles\r\n     * @param { boolean } ignoreCase\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    static contains(haystack: string, needles: string | string[], ignoreCase: boolean = false): boolean {\r\n        if (ignoreCase) {\r\n            haystack = haystack.toLowerCase();\r\n        }\r\n\r\n        needles = Array.isArray(needles) ? needles : [needles];\r\n\r\n        for (let needle of needles) {\r\n            if (ignoreCase) {\r\n                needle = needle.toLowerCase();\r\n            }\r\n\r\n            if (needle !== '' && haystack.includes(needle)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Determine if a given string contains all array values.\r\n     *\r\n     * @param { string } haystack\r\n     * @param { string[] } needles\r\n     * @param { boolean } ignoreCase\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    static containsAll(haystack: string, needles: string[], ignoreCase: boolean = false): boolean {\r\n        for (const needle of needles) {\r\n            if (this.doesntContain(haystack, needle, ignoreCase)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Determine if a given string doesn't contain a given substring.\r\n     *\r\n     * @param { string } haystack\r\n     * @param { string | string[] } needles\r\n     * @param { boolean } ignoreCase\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    static doesntContain(haystack: string, needles: string | string[], ignoreCase: boolean = false): boolean {\r\n        return !this.contains(haystack, needles, ignoreCase);\r\n    }\r\n\r\n    /**\r\n     * Convert the case of a string.\r\n     *\r\n     * @param { string } string\r\n     * @param { Mode | number } mode\r\n     *\r\n     * @return { string }\r\n     */\r\n    static convertCase(string: string, mode: Mode | number = Mode.MB_CASE_FOLD): string {\r\n        switch (mode) {\r\n            case Mode.MB_CASE_UPPER: {\r\n                string = string.toLocaleUpperCase();\r\n\r\n                break;\r\n            }\r\n            case Mode.MB_CASE_LOWER: {\r\n                string = string.toLocaleLowerCase();\r\n\r\n                break;\r\n            }\r\n            case Mode.MB_CASE_TITLE: {\r\n                string = this.title(string);\r\n\r\n                break;\r\n            }\r\n            case Mode.MB_CASE_FOLD: {\r\n                string = string.toLocaleLowerCase();\r\n\r\n                break;\r\n            }\r\n            case Mode.MB_CASE_UPPER_SIMPLE: {\r\n                string = string.toUpperCase();\r\n\r\n                break;\r\n            }\r\n            case Mode.MB_CASE_LOWER_SIMPLE: {\r\n                string = string.toLowerCase();\r\n\r\n                break;\r\n            }\r\n            case Mode.MB_CASE_TITLE_SIMPLE: {\r\n                string = this.title(string);\r\n\r\n                break;\r\n            }\r\n            case Mode.MB_CASE_FOLD_SIMPLE: {\r\n                string = string.toLowerCase();\r\n\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error('Argument #2 (mode) must be one of the Mode.MB_CASE_* constants');\r\n            }\r\n        }\r\n\r\n        return string;\r\n    }\r\n\r\n    /**\r\n     * Replace consecutive instances of a given character with a single character in the given string.\r\n     *\r\n     * @param { string } string\r\n     * @param { string | string[] } characters\r\n     *\r\n     * @return { string }\r\n     */\r\n    static deduplicate(string: string, characters: string | string[] = ' '): string {\r\n        if (Array.isArray(characters)) {\r\n            return characters.reduce((carry: string, character: string): string => carry.replace(new RegExp(`${character.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}+`, 'gu'), character), string);\r\n        }\r\n\r\n        return string.replace(new RegExp(`${preg_quote(characters)}+`, 'gu'), characters);\r\n    }\r\n\r\n    /**\r\n     * Determine if a given string ends with a given substring.\r\n     *\r\n     * @param { string } haystack\r\n     * @param { string | string[] } needles\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    static endsWith(haystack: string, needles: string | string[]): boolean {\r\n        needles = Array.isArray(needles) ? needles : [needles];\r\n\r\n        return needles.some((needle: string): boolean => needle !== '' && haystack.endsWith(needle));\r\n    }\r\n\r\n    /**\r\n     * Determine if a given string doesn't end with a given substring.\r\n     *\r\n     * @param { string } haystack\r\n     * @param { string | string[] } needles\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    static doesntEndWith(haystack: string, needles: string | string[]): boolean {\r\n        return !this.endsWith(haystack, needles);\r\n    }\r\n\r\n    /**\r\n     * Extracts an excerpt from text that matches the first instance of a phrase.\r\n     *\r\n     * @param { string } text\r\n     * @param { string } phrase\r\n     * @param { ExcerptOptions } options\r\n     *\r\n     * @return { string | null }\r\n     */\r\n    static excerpt(text: string, phrase: string = '', options: ExcerptOptions = {}): string | null {\r\n        const radius: number = options.radius ?? 100;\r\n        const omission: string = options.omission ?? '...';\r\n        const matches: RegExpMatchArray | null = text.match(new RegExp(`^(.*?)(${preg_quote(phrase)})(.*)$`, 'iu'));\r\n\r\n        if (matches === null) {\r\n            return null;\r\n        }\r\n\r\n        let start: string = (matches[1] as string).trimStart();\r\n        let end: string = (matches[3] as string).trimEnd();\r\n\r\n        start = this.of(this.substr(start, Math.max((start.length - radius), 0), radius))\r\n            .ltrim()\r\n            .unless(\r\n                (startWithRadius: Stringable): boolean => startWithRadius.exactly(start),\r\n                (startWithRadius: Stringable): Stringable => startWithRadius.prepend(omission))\r\n            .toString();\r\n\r\n        end = this.of(this.substr(end, 0, radius))\r\n            .rtrim()\r\n            .unless(\r\n                (endWithRadius: Stringable): boolean => endWithRadius.exactly(end),\r\n                (endWithRadius: Stringable): Stringable => endWithRadius.append(omission))\r\n            .toString();\r\n\r\n        return this.of(start).append(matches[2] as string, end).toString();\r\n    }\r\n\r\n    /**\r\n     * Cap a string with a single instance of a given value.\r\n     *\r\n     * @param { string } value\r\n     * @param { string } cap\r\n     *\r\n     * @return { string }\r\n     */\r\n    static finish(value: string, cap: string): string {\r\n        return value.endsWith(cap) ? value : value + cap;\r\n    }\r\n\r\n    /**\r\n     * Wrap the string with the given strings.\r\n     *\r\n     * @param { string } value\r\n     * @param { string } before\r\n     * @param { string | null } after\r\n     *\r\n     * @return string\r\n     */\r\n    static wrap(value: string, before: string, after: string | null = null): string {\r\n        return before + value + (after ?? before);\r\n    }\r\n\r\n    /**\r\n     * Unwrap the string with the given strings.\r\n     *\r\n     * @param { string } value\r\n     * @param { string } before\r\n     * @param { string | null } after\r\n     *\r\n     * @return { string }\r\n     */\r\n    static unwrap(value: string, before: string, after: string | null = null): string {\r\n        if (this.startsWith(value, before)) {\r\n            value = this.replaceFirst(before, '', value);\r\n        }\r\n\r\n        if (this.endsWith(value, after ?? before)) {\r\n            value = this.replaceLast(after ?? before, '', value);\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Determine if a given string matches a given pattern.\r\n     *\r\n     * @param { string | string[] } pattern\r\n     * @param { string } value\r\n     * @param { boolean } ignoreCase\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    static is(pattern: string | string[], value: string, ignoreCase: boolean = false): boolean {\r\n        let patterns: string[] = Array.isArray(pattern) ? pattern : [pattern];\r\n\r\n        for (let pattern of patterns) {\r\n            if (pattern === value) {\r\n                return true;\r\n            }\r\n\r\n            if (ignoreCase && pattern.toLowerCase() === value.toLowerCase()) {\r\n                return true;\r\n            }\r\n\r\n            pattern = pattern.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&').replace(/\\\\\\*/g, '.*');\r\n\r\n            const regex: RegExp = new RegExp(`^${pattern}$`, ignoreCase ? 'iu' : 'u');\r\n\r\n            if (regex.test(value)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Determine if a given string is 7-bit ASCII.\r\n     *\r\n     * @param { string } value\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    static isAscii(value: string): boolean {\r\n        return !/[^ -~\\t\\r\\n]/.test(value);\r\n    }\r\n\r\n    /**\r\n     * Determine if a given string is valid JSON.\r\n     *\r\n     * @param { string } value\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    static isJson(value: string): boolean {\r\n        try {\r\n            JSON.parse(value);\r\n        } catch {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Determine if a given value is a valid URL.\r\n     *\r\n     * @param { string } value\r\n     * @param { string[] } protocols\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    static isUrl(value: string, protocols: string[] = []): boolean {\r\n        const protocol: string = protocols.length === 0 ? 'https?|ftp|file|mailto|tel|data|irc|magnet' : protocols.join('|');\r\n\r\n        const pattern: RegExp = new RegExp(`^(?:${protocol}):\\\\/\\\\/(?:[\\\\w-]+(?:\\\\.[\\\\w-]+)+|localhost|\\\\d{1,3}(?:\\\\.\\\\d{1,3}){3})(?::\\\\d+)?(?:\\\\S*)?$`, 'i');\r\n\r\n        return pattern.test(value);\r\n    }\r\n\r\n    /**\r\n     * Determine if a given string is a valid UUID.\r\n     *\r\n     * @param { string } value\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    static isUuid(value: string): boolean {\r\n        return new RegExp(/^[\\da-f]{8}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{12}$/).test(value);\r\n    }\r\n\r\n    /**\r\n     * Determine if a given string is a valid ULID.\r\n     *\r\n     * @param { string } value\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    static isUlid(value: string): boolean {\r\n        if (typeof value !== 'string') {\r\n            return false;\r\n        }\r\n\r\n        if (value.length !== 26) {\r\n            return false;\r\n        }\r\n\r\n        if (value.length !== value.match(/[0123456789ABCDEFGHJKMNPQRSTVWXYZabcdefghjkmnpqrstvwxyz]/g)?.length) {\r\n            return false;\r\n        }\r\n\r\n        return Number.parseInt(value.charAt(0)) <= 7;\r\n    }\r\n\r\n    /**\r\n     * Convert a string to kebab case.\r\n     *\r\n     * @param { string } value\r\n     *\r\n     * @return { string }\r\n     */\r\n    static kebab(value: string): string {\r\n        return this.snake(value, '-');\r\n    }\r\n\r\n    /**\r\n     * Return the length of the given string.\r\n     *\r\n     * @param { string } value\r\n     *\r\n     * @return { number }\r\n     */\r\n    static length(value: string): number {\r\n        return value.length;\r\n    }\r\n\r\n    /**\r\n     * Limit the number of characters in a string.\r\n     *\r\n     * @param { string } value\r\n     * @param { number } limit\r\n     * @param { string } end\r\n     * @param { boolean } preserveWords\r\n     *\r\n     * @return { string }\r\n     */\r\n    static limit(value: string, limit: number = 100, end: string = '...', preserveWords: boolean = false): string {\r\n        if (value.length <= limit) {\r\n            return value;\r\n        }\r\n\r\n        if (!preserveWords) {\r\n            return this.substr(value, 0, limit).trim() + end;\r\n        }\r\n\r\n        value = value.replace(/[\\n\\r]+/, ' ');\r\n\r\n        const trimmed: string = this.substr(value, 0, limit).trim();\r\n\r\n        if (this.substr(value, limit, 1) === ' ') {\r\n            return `${trimmed}${end}`;\r\n        }\r\n\r\n        return `${trimmed.replace(/(.*)\\s.*/, '$1')}${end}`;\r\n    }\r\n\r\n    /**\r\n     * Convert the given string to lower-case.\r\n     *\r\n     * @param { string } value\r\n     *\r\n     * @return { string }\r\n     */\r\n    static lower(value: string): string {\r\n        return value.toLowerCase();\r\n    }\r\n\r\n    /**\r\n     * Limit the number of words in a string.\r\n     *\r\n     * @param { string } value\r\n     * @param { number } words\r\n     * @param { string } end\r\n     *\r\n     * @return { string }\r\n     */\r\n    static words(value: string, words: number = 100, end: string = '...'): string {\r\n        const wordsArray: string[] = value.match(/\\S+\\s*/g)?.splice(0, words) ?? [];\r\n\r\n        const result: string = wordsArray.join('');\r\n\r\n        if (wordsArray.length === 1 || this.length(value) === this.length(result)) {\r\n            return value;\r\n        }\r\n\r\n        return result.trim() + end;\r\n    }\r\n\r\n    /**\r\n     * Masks a portion of a string with a repeated character.\r\n     *\r\n     * @param { string } string\r\n     * @param { string } character\r\n     * @param { number } index\r\n     * @param { number | null } length\r\n     *\r\n     * @return { string }\r\n     */\r\n    static mask(string: string, character: string, index: number, length: number | null = null): string {\r\n        if (character === '') {\r\n            return string;\r\n        }\r\n\r\n        let start: number | string = index;\r\n        let endIndex: number = length ?? string.length;\r\n\r\n        if (start < 0) {\r\n            start = string.length + start;\r\n            endIndex = start + (length ?? 0);\r\n        }\r\n\r\n        if (endIndex === 0) {\r\n            endIndex = start;\r\n        }\r\n\r\n        let segment: string = string.substring(start, endIndex);\r\n\r\n        if (segment === '') {\r\n            return string;\r\n        }\r\n\r\n        let strLen: number = string.length;\r\n        let startIndex: number = index;\r\n\r\n        if (index < 0) {\r\n            startIndex = index < -strLen ? 0 : strLen + index;\r\n        }\r\n\r\n        start = string.substring(0, startIndex);\r\n\r\n        let segmentLen: number = segment.length;\r\n        let end: string = string.substring(startIndex + segmentLen);\r\n\r\n        return start + character.substring(0, 1).repeat(segmentLen) + end;\r\n    }\r\n\r\n    /**\r\n     * Get the string matching the given pattern.\r\n     *\r\n     * @param { RegExp } pattern\r\n     * @param { string } subject\r\n     *\r\n     * @return { string }\r\n     */\r\n    static match(pattern: RegExp, subject: string): string {\r\n        const matches: RegExpExecArray | null = pattern.exec(subject);\r\n\r\n        if (matches === null) {\r\n            return '';\r\n        }\r\n\r\n        return matches[1] ?? matches[0];\r\n    }\r\n\r\n    /**\r\n     * Determine if a given string matches a given pattern.\r\n     *\r\n     * @param { RegExp | RegExp[] } pattern\r\n     * @param { string } value\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    static isMatch(pattern: RegExp | RegExp[], value: string): boolean {\r\n        pattern = Array.isArray(pattern) ? pattern : [pattern];\r\n\r\n        for (const item of pattern) {\r\n            if (item.exec(value)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get the string matching the given pattern.\r\n     *\r\n     * @param { RegExp } pattern\r\n     * @param { string } subject\r\n     *\r\n     * @return { string[] }\r\n     */\r\n    static matchAll(pattern: RegExp, subject: string): string[] {\r\n        const flags: string = [...new Set([...(pattern.toString().match(/[gimsuy]/g) || []), 'g'])].join('');\r\n        const expression: RegExp = new RegExp(pattern, flags);\r\n\r\n        const matches: RegExpMatchArray[] = [...subject.matchAll(expression)];\r\n\r\n        if (matches.length === 0) {\r\n            return [];\r\n        }\r\n\r\n        return matches.map((match: RegExpMatchArray): string => String(match.length === 1 ? match[0] : match[1]));\r\n    }\r\n\r\n    /**\r\n     * Remove all non-numeric characters from a string.\r\n     *\r\n     * @param { string } value\r\n     *\r\n     * @return { string }\r\n     */\r\n    static numbers(value: string): string {\r\n        return value.replace(/\\D/g, '');\r\n    }\r\n\r\n    /**\r\n     * Pad both sides of a string with another.\r\n     *\r\n     * @param { string } value\r\n     * @param { number } length\r\n     * @param { string } pad\r\n     *\r\n     * @return { string }\r\n     */\r\n    static padBoth(value: string, length: number, pad: string = ' '): string {\r\n        const short: number = Math.max(0, length - value.length);\r\n        const shortLeft: number = Math.floor(short / 2);\r\n        const shortRight: number = Math.ceil(short / 2);\r\n\r\n        return pad.repeat(shortLeft).substring(0, shortLeft) + value + pad.repeat(shortRight).substring(0, shortRight);\r\n    }\r\n\r\n    /**\r\n     * Pad the left side of a string with another.\r\n     *\r\n     * @param { string } value\r\n     * @param { number } length\r\n     * @param { string } pad\r\n     *\r\n     * @return { string }\r\n     */\r\n    static padLeft(value: string, length: number, pad: string = ' '): string {\r\n        const short: number = Math.max(0, length - (value.length ?? 0));\r\n\r\n        return pad.repeat(short).substring(0, short) + value;\r\n    }\r\n\r\n    /**\r\n     * Pad the right side of a string with another.\r\n     *\r\n     * @param { string } value\r\n     * @param { number } length\r\n     * @param { string } pad\r\n     *\r\n     * @return { string }\r\n     */\r\n    static padRight(value: string, length: number, pad: string = ' '): string {\r\n        const short: number = Math.max(0, length - value.length);\r\n\r\n        return value + pad.repeat(short).substring(0, short);\r\n    }\r\n\r\n    /**\r\n     * Get the plural form of an English word.\r\n     *\r\n     * @param { string } value\r\n     * @param { number | array } count\r\n     *\r\n     * @return { string }\r\n     */\r\n    static plural(value: string, count: number | number[] = 2): string {\r\n        if ((count !== undefined && count === 1) || value.trim() === '') {\r\n            return value;\r\n        }\r\n\r\n        // List of rules for plural words.\r\n        const plural: Record<string, string> = {\r\n            // Special cases (unchanged plurals)\r\n            '^(.*)menu$': '$1menus',\r\n            '^tights$'  : 'tights',\r\n            '^shorts$'  : 'shorts',\r\n            '^glasses$' : 'glasses',\r\n            '^pants$'   : 'pants',\r\n\r\n            // -us -> -i (second declension nouns)\r\n            '(alumn|bacill|cact|foc|fung|nucle|radi|stimul|syllab|termin|vir)us$': '$1i',\r\n            '(vir)us$'                                                           : '$1i',\r\n\r\n            // -um/on -> -a (neuter nouns)\r\n            '([ti])um$'   : '$1a',\r\n            '(tax)on$'    : '$1a',\r\n            '(criteri)on$': '$1a',\r\n\r\n            // -ix/ex -> -ices\r\n            '(matr)ix$'    : '$1ices',\r\n            '(vert|ind)ex$': '$1ices',\r\n\r\n            // -o -> -oes\r\n            '(buffal|her|potat|tomat|volcan)o$': '$1oes',\r\n\r\n            // -ouse -> -ouses\r\n            '(h|bl)ouse$': '$1ouses',\r\n            'ouse$'      : 'ouses',\r\n\r\n            // -y -> -ies\r\n            '([^aeiouy]|qu)y$': '$1ies',\r\n\r\n            // -f/fe -> -ves\r\n            '([lr])f$'             : '$1ves',\r\n            '([^fo])fe$'           : '$1ves',\r\n            '(shea|loa|lea|thie)f$': '$1ves',\r\n            '(li|wi|kni)fe$'       : '$1ves',\r\n\r\n            // -is -> -es\r\n            '(analys|ax|cris|test|thes)is$': '$1es',\r\n\r\n            // -e exceptions\r\n            '(alias|status|bus)$'          : '$1es',\r\n            '(shoe|slave)$'                : '$1s',\r\n            '(corpse)$'                    : '$1s',\r\n            '(drive|dive|hive|olive|tive)$': '$1s',\r\n\r\n            // -x -> -xes\r\n            '([ftw]ax)$': '$1es',\r\n\r\n            // -ouse -> -ice\r\n            '([m|l])ouse$': '$1ice',\r\n\r\n            // -e -> -es\r\n            '(x|ch|ss|sh)$': '$1es',\r\n            'o$'           : 'oes',\r\n\r\n            // -ze -> -zes\r\n            '(quiz)$': '$1zes',\r\n\r\n            // -ox -> -oxen\r\n            '^(ox)$': '$1en',\r\n\r\n            // -person -> -people\r\n            '(p)erson$': '$1eople',\r\n\r\n            // Irregular singulars\r\n            '(m)an$'  : '$1en',\r\n            '(c)hild$': '$1hildren',\r\n            '(f)oot$' : '$1eet',\r\n            '(m)ouse$': '$1ice',\r\n            '(t)ooth$': '$1eeth',\r\n            '(g)oose$': '$1eese',\r\n\r\n            // -news (unchanged)\r\n            '(n)ews$': '$1ews',\r\n\r\n            // -eau -> -eaus\r\n            'eau$': 'eaus',\r\n\r\n            // -sis -> -ses\r\n            '(^analy)sis$'                                                 : '$1ses',\r\n            '((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)sis$': '$1$2ses',\r\n\r\n            // -ovie -> -ovies\r\n            '(m)ovie$': '$1ovies',\r\n\r\n            // -eries -> -eries (unchanged)\r\n            '(s)eries$': '$1eries',\r\n\r\n            // -us -> -uses\r\n            '([^a])us$': '$1uses',\r\n            'us$'      : 'uses',\r\n\r\n            // -status -> -statuses\r\n            '(s)tatus$': '$1tatuses',\r\n\r\n            // -campus -> -campuses\r\n            '(c)ampus$': '$1ampuses',\r\n\r\n            // General case (add -s)\r\n            '$': 's'\r\n        };\r\n\r\n        // List of words that change irregularly.\r\n        const irregular: Record<string, string> = {\r\n            // A\r\n            'abuse'    : 'abuses',\r\n            'alumna'   : 'alumnae',\r\n            'alumnus'  : 'alumni',\r\n            'analysis' : 'analyses',\r\n            'appendix' : 'appendices',\r\n            'atlas'    : 'atlases',\r\n            'avalanche': 'avalanches',\r\n            'axis'     : 'axes',\r\n            'axe'      : 'axes',\r\n\r\n            // B\r\n            'bacillus' : 'bacilli',\r\n            'bacterium': 'bacteria',\r\n            'basis'    : 'bases',\r\n            'beau'     : 'beaux',\r\n            'beef'     : 'beefs',\r\n            'blouse'   : 'blouses',\r\n            'brother'  : 'brothers',\r\n            'brownie'  : 'brownies',\r\n            'bureau'   : 'bureaux',\r\n\r\n            // C\r\n            'cache'     : 'caches',\r\n            'cactus'    : 'cacti',\r\n            'cafe'      : 'cafes',\r\n            'calf'      : 'calves',\r\n            'canvas'    : 'canvases',\r\n            'cave'      : 'caves',\r\n            'chateau'   : 'chateaux',\r\n            'child'     : 'children',\r\n            'cookie'    : 'cookies',\r\n            'corpus'    : 'corpuses',\r\n            'cow'       : 'cows',\r\n            'crisis'    : 'crises',\r\n            'criterion' : 'criteria',\r\n            'curriculum': 'curricula',\r\n            'curve'     : 'curves',\r\n\r\n            // D\r\n            'datum'    : 'data',\r\n            'deer'     : 'deer',\r\n            'demo'     : 'demos',\r\n            'diagnosis': 'diagnoses',\r\n            'domino'   : 'dominoes',\r\n\r\n            // E\r\n            'echo'    : 'echoes',\r\n            'elf'     : 'elves',\r\n            'ellipsis': 'ellipses',\r\n            'emphasis': 'emphases',\r\n            'epoch'   : 'epochs',\r\n\r\n            // F\r\n            'fish'   : 'fish',\r\n            'focus'  : 'foci',\r\n            'foe'    : 'foes',\r\n            'foot'   : 'feet',\r\n            'formula': 'formulae',\r\n            'fungus' : 'fungi',\r\n\r\n            // G\r\n            'ganglion': 'ganglions',\r\n            'gas'     : 'gases',\r\n            'genie'   : 'genies',\r\n            'genus'   : 'genera',\r\n            'goose'   : 'geese',\r\n            'graffito': 'graffiti',\r\n            'grave'   : 'graves',\r\n\r\n            // H\r\n            'half'        : 'halves',\r\n            'hippopotamus': 'hippopotami',\r\n            'hoax'        : 'hoaxes',\r\n            'hoof'        : 'hoofs',\r\n            'human'       : 'humans',\r\n\r\n            // I\r\n            'iris': 'irises',\r\n\r\n            // K\r\n            'knife': 'knives',\r\n\r\n            // L\r\n            'larva': 'larvae',\r\n            'leaf' : 'leaves',\r\n            'lens' : 'lenses',\r\n            'life' : 'lives',\r\n            'loaf' : 'loaves',\r\n\r\n            // M\r\n            'man'       : 'men',\r\n            'matrix'    : 'matrices',\r\n            'means'     : 'means',\r\n            'medium'    : 'media',\r\n            'memorandum': 'memoranda',\r\n            'money'     : 'monies',\r\n            'mongoose'  : 'mongooses',\r\n            'mouse'     : 'mice',\r\n            'motto'     : 'mottoes',\r\n            'move'      : 'moves',\r\n            'mythos'    : 'mythoi',\r\n\r\n            // N\r\n            'nebula'  : 'nebulae',\r\n            'neurosis': 'neuroses',\r\n            'niche'   : 'niches',\r\n            'niveau'  : 'niveaux',\r\n            'nucleus' : 'nuclei',\r\n            'numen'   : 'numina',\r\n\r\n            // O\r\n            'oasis'    : 'oases',\r\n            'occiput'  : 'occiputs',\r\n            'octopus'  : 'octopuses',\r\n            'offspring': 'offspring',\r\n            'opus'     : 'opuses',\r\n            'ox'       : 'oxen',\r\n\r\n            // P\r\n            'parenthesis': 'parentheses', 'passerby': 'passersby',\r\n            'penis'      : 'penises',\r\n            'person'     : 'people',\r\n            'phenomenon' : 'phenomena',\r\n            'plateau'    : 'plateaux',\r\n\r\n            // R\r\n            'radius'   : 'radii',\r\n            'runner-up': 'runners-up',\r\n\r\n            // S\r\n            'safe'      : 'safes',\r\n            'save'      : 'saves',\r\n            'scarf'     : 'scarves',\r\n            'self'      : 'selves',\r\n            'series'    : 'series',\r\n            'sex'       : 'sexes',\r\n            'sheep'     : 'sheep',\r\n            'shelf'     : 'shelves',\r\n            'sieve'     : 'sieves',\r\n            'soliloquy' : 'soliloquies',\r\n            'son-in-law': 'sons-in-law',\r\n            'species'   : 'species',\r\n            'stadium'   : 'stadiums',\r\n            'stimulus'  : 'stimuli',\r\n            'stratum'   : 'strata',\r\n            'swine'     : 'swine',\r\n            'syllabus'  : 'syllabi',\r\n            'synthesis' : 'syntheses',\r\n\r\n            // T\r\n            'testis' : 'testes',\r\n            'thesis' : 'theses',\r\n            'thief'  : 'thieves',\r\n            'tooth'  : 'teeth',\r\n            'tornado': 'tornadoes',\r\n            'trilby' : 'trilbys',\r\n            'turf'   : 'turfs',\r\n\r\n            // V\r\n            'valve'  : 'valves',\r\n            'volcano': 'volcanoes',\r\n\r\n            // W\r\n            'wave': 'waves',\r\n            'wife': 'wives',\r\n            'wolf': 'wolves',\r\n\r\n            // Z\r\n            'zombie': 'zombies'\r\n        };\r\n\r\n        // List of words that do not change.\r\n        const uncountable: Set<string> = new Set([\r\n            // A\r\n            'advice',\r\n            'aircraft',\r\n            'amoyese',\r\n            'art',\r\n            'audio',\r\n\r\n            // B\r\n            'baggage',\r\n            'bison',\r\n            'borghese',\r\n            'bream',\r\n            'breeches',\r\n            'britches',\r\n            'buffalo',\r\n            'butter',\r\n\r\n            // C\r\n            'cantus',\r\n            'carp',\r\n            'cattle',\r\n            'chassis',\r\n            'clippers',\r\n            'clothing',\r\n            'coal',\r\n            'cod',\r\n            'coitus',\r\n            'compensation',\r\n            'congoese',\r\n            'contretemps',\r\n            'coreopsis',\r\n            'corps',\r\n            'cotton',\r\n\r\n            // D\r\n            'data',\r\n            'debris',\r\n            'deer',\r\n            'diabetes',\r\n            'djinn',\r\n\r\n            // E\r\n            'education',\r\n            'eland',\r\n            'elk',\r\n            'emoji',\r\n            'equipment',\r\n            'evidence',\r\n\r\n            // F\r\n            'faroese',\r\n            'feedback',\r\n            'fish',\r\n            'flounder',\r\n            'flour',\r\n            'foochowese',\r\n            'food',\r\n            'furniture',\r\n\r\n            // G\r\n            'gallows',\r\n            'genevese',\r\n            'genoese',\r\n            'gilbertese',\r\n            'gold',\r\n\r\n            // H\r\n            'headquarters',\r\n            'herpes',\r\n            'hijinks',\r\n            'homework',\r\n            'hovercraft',\r\n            'hottentotese',\r\n\r\n            // I\r\n            'impatience',\r\n            'information',\r\n            'innings',\r\n\r\n            // J\r\n            'jackanapes',\r\n            'jeans',\r\n            'jedi',\r\n\r\n            // K\r\n            'kin',\r\n            'kiplingese',\r\n            'knowledge',\r\n            'kongoese',\r\n\r\n            // L\r\n            'leather',\r\n            'love',\r\n            'lucchese',\r\n            'luggage',\r\n\r\n            // M\r\n            'mackerel',\r\n            'Maltese',\r\n            'management',\r\n            'metadata',\r\n            'mews',\r\n            'money',\r\n            'moose',\r\n            'mumps',\r\n            'music',\r\n\r\n            // N\r\n            'nankingese',\r\n            'news',\r\n            'nexus',\r\n            'niasese',\r\n            'nutrition',\r\n\r\n            // O\r\n            'oil',\r\n            'offspring',\r\n\r\n            // P\r\n            'patience',\r\n            'pekingese',\r\n            'piedmontese',\r\n            'pike',\r\n            'pincers',\r\n            'pistoiese',\r\n            'plankton',\r\n            'pliers',\r\n            'pokemon',\r\n            'police',\r\n            'polish',\r\n            'portuguese',\r\n            'proceedings',\r\n            'progress',\r\n\r\n            // Q\r\n            // (none yet)\r\n\r\n            // R\r\n            'rabies',\r\n            'rain',\r\n            'research',\r\n            'rhinoceros',\r\n            'rice',\r\n\r\n            // S\r\n            'salmon',\r\n            'sand',\r\n            'sarawakese',\r\n            'scissors',\r\n            'sea[- ]bass',\r\n            'series',\r\n            'shavese',\r\n            'shears',\r\n            'sheep',\r\n            'shrimp',\r\n            'siemens',\r\n            'silk',\r\n            'sms',\r\n            'soap',\r\n            'social media',\r\n            'spacecraft',\r\n            'spam',\r\n            'species',\r\n            'staff',\r\n            'sugar',\r\n            'swine',\r\n\r\n            // T\r\n            'talent',\r\n            'toothpaste',\r\n            'traffic',\r\n            'travel',\r\n            'trousers',\r\n            'trout',\r\n            'tuna',\r\n\r\n            // U\r\n            'us',\r\n\r\n            // V\r\n            'vermontese',\r\n            'vinegar',\r\n\r\n            // W\r\n            'weather',\r\n            'wenchowese',\r\n            'wheat',\r\n            'whiting',\r\n            'wildebeest',\r\n            'wood',\r\n            'wool',\r\n\r\n            // Y\r\n            'yengeese',\r\n            'you'\r\n        ]);\r\n\r\n        if (uncountable.has(value.toLowerCase())) {\r\n            return matchCase(value, value);\r\n        }\r\n\r\n        for (const word in irregular) {\r\n            const pattern: RegExp = new RegExp(`${word}$`, 'i');\r\n\r\n            if (pattern.test(value)) {\r\n                return matchCase(value.replace(pattern, (irregular[word] as string)), value);\r\n            }\r\n        }\r\n\r\n        for (const word in plural) {\r\n            const pattern: RegExp = new RegExp(word, 'i');\r\n\r\n            if (pattern.test(value)) {\r\n                return matchCase(value.replace(pattern, (plural[word] as string)), value);\r\n            }\r\n        }\r\n\r\n        return matchCase(value, value);\r\n    }\r\n\r\n    /**\r\n     * Pluralize the last word of an English, studly caps case string.\r\n     *\r\n     * @param { string } value\r\n     * @param { number | array } count\r\n     *\r\n     * @return { string }\r\n     */\r\n    static pluralStudly(value: string, count: number | number[] = 2): string {\r\n        const parts: string[] = value.split(/(.)(?=[A-Z])/);\r\n\r\n        const lastWord: string = (parts.pop() as string);\r\n\r\n        return parts.join('') + this.ucfirst(this.plural(lastWord, count));\r\n    }\r\n\r\n    /**\r\n     * Pluralize the last word of an English, Pascal case string.\r\n     *\r\n     * @param { string } value\r\n     * @param { number | array } count\r\n     *\r\n     * @return { string }\r\n     */\r\n    static pluralPascal(value: string, count: number | number[] = 2): string {\r\n        return this.pluralStudly(value, count);\r\n    }\r\n\r\n    /**\r\n     * Generate a random, secure password.\r\n     *\r\n     * @param { number } length\r\n     * @param { boolean } letters\r\n     * @param { boolean } numbers\r\n     * @param { boolean } symbols\r\n     * @param { boolean } spaces\r\n     *\r\n     * @return { string }\r\n     */\r\n    static password(length: number = 32, letters: boolean = true, numbers: boolean = true, symbols: boolean = true, spaces: boolean = false): string {\r\n        let password: string[] = [];\r\n        let collection: Record<string, string[]> = {};\r\n\r\n        if (letters) {\r\n            collection.letters = [\r\n                'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',\r\n                'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\r\n                'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G',\r\n                'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R',\r\n                'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\r\n            ];\r\n        }\r\n\r\n        if (numbers) {\r\n            collection.numbers = [\r\n                '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\r\n            ];\r\n        }\r\n\r\n        if (symbols) {\r\n            collection.symbols = [\r\n                '~', '!', '#', '$', '%', '^', '&', '*', '(', ')', '-',\r\n                '_', '.', ',', '<', '>', '?', '/', '\\\\', '{', '}', '[',\r\n                ']', '|', ':', ';',\r\n            ];\r\n        }\r\n\r\n        if (spaces) {\r\n            collection.spaces = [' '];\r\n        }\r\n\r\n        for (const option in collection) {\r\n            const options: string[] = collection[option] as string[];\r\n\r\n            password.push(options[Math.floor(Math.random() * options.length)] as string);\r\n        }\r\n\r\n        const options: string[] = Object.values(collection).flat();\r\n        length = length - password.length;\r\n\r\n        for (let i: number = 0; i < length; i++) {\r\n            const index: number = Math.floor(Math.random() * options.length);\r\n\r\n            password.push(options[index] as string);\r\n        }\r\n\r\n        return password.toSorted((): number => Math.random() - 0.5).reduce((previous: string, current: string): string => current + previous, '');\r\n    }\r\n\r\n    /**\r\n     * Find the position of the first occurrence of a given substring in a string.\r\n     *\r\n     * @param { string } haystack\r\n     * @param { string } needle\r\n     * @param { number } offset\r\n     *\r\n     * @return { number | false }\r\n     */\r\n    static position(haystack: string, needle: string, offset: number = 0): number | false {\r\n        const position: number = haystack.indexOf(needle, Math.max(offset, 0));\r\n\r\n        return position === -1 ? false : position;\r\n    }\r\n\r\n    /**\r\n     * Generate a more truly \"random\" alpha-numeric string.\r\n     *\r\n     * @param { number } length\r\n     *\r\n     * @return { string }\r\n     */\r\n    static random(length: number = 16): string {\r\n        if (this.randomStringFactory !== null) {\r\n            return this.randomStringFactory(length);\r\n        }\r\n\r\n        let byteSize: number = Math.ceil((length) / 3) * 3;\r\n\r\n        let bytes: string = crypto.getRandomValues(new Uint8Array(byteSize)).join('');\r\n\r\n        let string: string = btoa(bytes);\r\n\r\n        for (const character of ['/', '+', '=']) {\r\n            string = string.replace(character, '');\r\n        }\r\n\r\n        return string.substring(0, length);\r\n    }\r\n\r\n    /**\r\n     * Set the callable that will be used to generate random strings.\r\n     *\r\n     * @param { ((length: number) => string) | null } factory\r\n     *\r\n     * @return { void }\r\n     */\r\n    static createRandomStringsUsing(factory: ((length: number) => string) | null = null): void {\r\n        this.randomStringFactory = factory;\r\n    }\r\n\r\n    /**\r\n     * Set the sequence that will be used to generate random strings.\r\n     *\r\n     * @param { (string | undefined)[] } sequence\r\n     * @param { Function | null } whenMissing\r\n     *\r\n     * @return { void }\r\n     */\r\n    static createRandomStringsUsingSequence(sequence: (string | undefined)[], whenMissing: Function | null = null): void {\r\n        let next: number = 0;\r\n\r\n        whenMissing ??= (length: number): string => {\r\n            const factoryCache: Function | null = this.randomStringFactory;\r\n\r\n            this.randomStringFactory = null;\r\n\r\n            const randomString: string = this.random(length);\r\n\r\n            this.randomStringFactory = factoryCache;\r\n\r\n            next++;\r\n\r\n            return randomString;\r\n        };\r\n\r\n        this.createRandomStringsUsing((length: number): any => {\r\n            if (sequence[next] !== undefined) {\r\n                return sequence[next++];\r\n            }\r\n\r\n            return whenMissing(length);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Indicate that random strings should be created normally and not using a custom factory.\r\n     *\r\n     * @return { void }\r\n     */\r\n    static createRandomStringsNormally(): void {\r\n        this.randomStringFactory = null;\r\n    }\r\n\r\n    /**\r\n     * Repeat the given string.\r\n     *\r\n     * @param { string } string\r\n     * @param { number } times\r\n     *\r\n     * @return { string }\r\n     */\r\n    static repeat(string: string, times: number = 1): string {\r\n        return string.repeat(times);\r\n    }\r\n\r\n    /**\r\n     * Replace a given value in the string sequentially with an array.\r\n     *\r\n     * @param { string[] } replace\r\n     * @param { string } subject\r\n     * @param { string } search\r\n     *\r\n     * @return { string }\r\n     */\r\n    static replaceArray(search: string, replace: string[], subject: string): string {\r\n        const segments: string[] = subject.split(search);\r\n\r\n        let result: string = segments.shift()!;\r\n\r\n        for (const segment of segments) {\r\n            result += Str.toStringOr(replace.shift() ?? search, search) + segment;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Replace the given value in the given string.\r\n     *\r\n     * @param { string | string[] } search\r\n     * @param { string | string[] } replace\r\n     * @param { string | string[] } subject\r\n     * @param { boolean } caseSensitive\r\n     *\r\n     * @return { string | string[] }\r\n     */\r\n    static replace(search: string | string[], replace: string | string[], subject: string, caseSensitive?: boolean): string;\r\n    static replace(search: string | string[], replace: string | string[], subject: string[], caseSensitive?: boolean): string[];\r\n    static replace(search: string | string[], replace: string | string[], subject: string | string[], caseSensitive: boolean = true): string | string[] {\r\n        search = Array.isArray(search) ? search : [search];\r\n\r\n        for (const term of search) {\r\n            const index: number = search.indexOf(term);\r\n            const $subject: string = Array.isArray(subject) ? subject[index] ?? '' : subject;\r\n            const $replace: string = Array.isArray(replace) ? replace[index] ?? '' : replace;\r\n            const pattern: string | RegExp = caseSensitive ? term : new RegExp(term, 'gi');\r\n            const replacement: string = $subject.replaceAll(pattern, $replace);\r\n\r\n            if (Array.isArray(subject)) {\r\n                subject[index] = replacement;\r\n            } else {\r\n                subject = replacement;\r\n            }\r\n        }\r\n\r\n        return subject;\r\n    }\r\n\r\n    /**\r\n     * Replace the first occurrence of a given value in the string.\r\n     *\r\n     * @param { string } search\r\n     * @param { string } replace\r\n     * @param { string } subject\r\n     *\r\n     * @return { string }\r\n     */\r\n    static replaceFirst(search: string, replace: string, subject: string): string {\r\n        if (search === '') {\r\n            return subject;\r\n        }\r\n\r\n        let position: number = subject.indexOf(search);\r\n\r\n        if (position !== -1) {\r\n            return subject.replace(search, replace);\r\n        }\r\n\r\n        return subject;\r\n    }\r\n\r\n    /**\r\n     * Replace the first occurrence of the given value if it appears at the start of the string.\r\n     *\r\n     * @param { string } search\r\n     * @param { string } replace\r\n     * @param { string } subject\r\n     *\r\n     * @return { string }\r\n     */\r\n    static replaceStart(search: string, replace: string, subject: string): string {\r\n        if (search === '') {\r\n            return subject;\r\n        }\r\n\r\n        if (this.startsWith(subject, search)) {\r\n            return this.replaceFirst(search, replace, subject);\r\n        }\r\n\r\n        return subject;\r\n    }\r\n\r\n    /**\r\n     * Replace the last occurrence of a given value in the string.\r\n     *\r\n     * @param { string } search\r\n     * @param { string } replace\r\n     * @param { string } subject\r\n     *\r\n     * @return { string }\r\n     */\r\n    static replaceLast(search: string, replace: string, subject: string): string {\r\n        if (search === '') {\r\n            return subject;\r\n        }\r\n\r\n        let position: number = subject.lastIndexOf(search);\r\n\r\n        if (position !== -1) {\r\n            return subject.substring(0, position) + replace + subject.substring(position + search.length);\r\n        }\r\n\r\n        return subject;\r\n    }\r\n\r\n    /**\r\n     * Replace the last occurrence of a given value if it appears at the end of the string.\r\n     *\r\n     * @param { string } search\r\n     * @param { string } replace\r\n     * @param { string } subject\r\n     *\r\n     * @return { string }\r\n     */\r\n    static replaceEnd(search: string, replace: string, subject: string): string {\r\n        if (search === '') {\r\n            return subject;\r\n        }\r\n\r\n        if (this.endsWith(subject, search)) {\r\n            return this.replaceLast(search, replace, subject);\r\n        }\r\n\r\n        return subject;\r\n    }\r\n\r\n    /**\r\n     * Replace the patterns matching the given regular expression.\r\n     *\r\n     * @param { RegExp | RegExp[] } pattern\r\n     * @param { string | string[] | ((match: string[]) => string) } replace\r\n     * @param { string } subject\r\n     * @param { number } limit\r\n     *\r\n     * @return { string }\r\n     */\r\n    static replaceMatches(pattern: RegExp | RegExp[], replace: string | string[] | ((match: string[]) => string), subject: string, limit: number = -1): string {\r\n        const patterns: RegExp[] = Array.isArray(pattern) ? pattern : [pattern];\r\n\r\n        for (const pattern of patterns) {\r\n            const index: number = patterns.indexOf(pattern);\r\n            const flags: string = [...new Set([...(pattern.toString().match(/[gimsuy]/g) || []), 'g'])].join('');\r\n            const expression: RegExp = new RegExp(pattern, flags);\r\n            let count: number = 0;\r\n\r\n            if (typeof replace === 'function') {\r\n                subject = subject.replace(expression, (substring: string, ...args: any[]): string => {\r\n                    if (limit < 0 || count < limit) {\r\n                        count++;\r\n\r\n                        return replace([substring, args[0]]);\r\n                    }\r\n\r\n                    return substring;\r\n                });\r\n            } else {\r\n                const replacement: string = Array.isArray(replace) ? replace[index] ?? '' : replace;\r\n\r\n                subject = subject.replace(expression, (match: string): string => {\r\n                    if (limit < 0 || count < limit) {\r\n                        count++;\r\n\r\n                        return replacement;\r\n                    }\r\n\r\n                    return match;\r\n                });\r\n            }\r\n        }\r\n\r\n        return subject;\r\n    }\r\n\r\n    /**\r\n     * Remove any occurrence of the given string in the subject.\r\n     *\r\n     * @param { string | string[] } search\r\n     * @param { string | string[] } subject\r\n     * @param { boolean } caseSensitive\r\n     *\r\n     * @return { string | string[] }\r\n     */\r\n    static remove(search: string | string[], subject: string, caseSensitive?: boolean): string\r\n    static remove(search: string | string[], subject: string[], caseSensitive?: boolean): string[]\r\n    static remove(search: string | string[], subject: string | string[], caseSensitive: boolean = true): string | string[] {\r\n        // @ts-ignore\r\n        return this.replace(search, '', subject, caseSensitive ?? true);\r\n    }\r\n\r\n    /**\r\n     * Reverse the given string.\r\n     *\r\n     * @param { string } value\r\n     *\r\n     * @return { string }\r\n     */\r\n    static reverse(value: string): string {\r\n        return value.split('').reverse().join('');\r\n    }\r\n\r\n    /**\r\n     * Begin a string with a single instance of a given value.\r\n     *\r\n     * @param { string } value\r\n     * @param { string } prefix\r\n     *\r\n     * @return { string }\r\n     */\r\n    static start(value: string, prefix: string): string {\r\n        const quoted: string = preg_quote(prefix, '/');\r\n\r\n        return prefix + value.replace(new RegExp(`^(?:${quoted})+`, 'u'), '');\r\n    }\r\n\r\n    /**\r\n     * Convert the given string to upper-case.\r\n     *\r\n     * @param { string } value\r\n     *\r\n     * @return { string }\r\n     */\r\n    static upper(value: string): string {\r\n        return value.toUpperCase();\r\n    }\r\n\r\n    /**\r\n     * Convert the given string to title case.\r\n     *\r\n     * @param { string } value\r\n     *\r\n     * @return { string }\r\n     */\r\n    static title(value: string): string {\r\n        return value.split(/[^A-Za-z]/)\r\n            .map((word: string): string => word === '' ? word : this.ucfirst(word[0] + word.substring(1).toLowerCase()))\r\n            .join(' ');\r\n    }\r\n\r\n    /**\r\n     * Convert the given string to title case for each word.\r\n     *\r\n     * @param { string } value\r\n     *\r\n     * @return { string }\r\n     */\r\n    static headline(value: string): string {\r\n        let parts: string[] = value.split(' ');\r\n\r\n        parts = parts.length > 1\r\n            ? parts.map((part: string): string => this.title(part))\r\n            : this.ucsplit(parts.join('_')).map((part: string): string => this.title(part));\r\n\r\n        let collapsed: string = this.replace(['-', '_', ' '], '_', parts.join('_'));\r\n\r\n        return collapsed.split('_').filter(Boolean).join(' ').trim();\r\n    }\r\n\r\n    /**\r\n     * Convert the given string to APA-style title case.\r\n     *\r\n     * @see https://apastyle.apa.org/style-grammar-guidelines/capitalization/title-case\r\n     *\r\n     * @param { string } value\r\n     *\r\n     * @return { string }\r\n     */\r\n    static apa(value: string): string {\r\n        if (value === '') {\r\n            return value;\r\n        }\r\n\r\n        const minorWords: Set<string> = new Set([\r\n            'and', 'as', 'but', 'for', 'if', 'nor', 'or', 'so', 'yet', 'a', 'an',\r\n            'the', 'at', 'by', 'in', 'of', 'off', 'on', 'per', 'to', 'up', 'via',\r\n        ]);\r\n\r\n        const endPunctuation: Set<string> = new Set(['.', '!', '?', ':', '', ',']);\r\n\r\n        let words: string[] = value.split(/\\s+/).filter(Boolean);\r\n\r\n        words[0] = (words[0] as string).charAt(0).toUpperCase() + (words[0] as string).slice(1).toLowerCase();\r\n\r\n        for (let i: number = 0; i < words.length; i++) {\r\n            let lowercaseWord: string = (words[i] as string).toLowerCase();\r\n\r\n            if (lowercaseWord.includes('-')) {\r\n                let hyphenatedWords: string[] = lowercaseWord.split('-');\r\n\r\n                hyphenatedWords = hyphenatedWords.map((part: string): string => (minorWords.has(part) && part.length <= 3) ? part : this.ucfirst(part));\r\n\r\n                words[i] = hyphenatedWords.join('-');\r\n            } else if (minorWords.has(lowercaseWord) && lowercaseWord.length <= 3 && !(i === 0 || endPunctuation.has((words[i - 1] as string).slice(-1)))) {\r\n                words[i] = lowercaseWord;\r\n            } else {\r\n                words[i] = this.ucfirst(lowercaseWord);\r\n            }\r\n        }\r\n\r\n        return words.join(' ');\r\n    }\r\n\r\n    /**\r\n     * Get the singular form of an English word.\r\n     *\r\n     * @param { string } value\r\n     *\r\n     * @return { string }\r\n     */\r\n    static singular(value: string): string {\r\n        // List of rules for singular words.\r\n        const singular: Record<string, string> = {\r\n            // Special cases\r\n            '^(.*)(menu)s$': '$1$2',\r\n            '^tights$'     : 'tights',\r\n            '^shorts$'     : 'shorts',\r\n            '^glasses$'    : 'glasses',\r\n            '^pants$'      : 'pants',\r\n\r\n            // -us -> -i (second declension nouns)\r\n            '(alumn|bacill|cact|foc|fung|nucle|radi|stimul|syllab|termin|viri?)i$': '$1us',\r\n            '(vir)i$'                                                             : '$1us',\r\n\r\n            // -a -> -um/on (neuter nouns)\r\n            '([ti])a$'            : '$1um',\r\n            '([ti])a(?<!regatta)$': '$1um',\r\n            '(tax)a$'             : '$1on',\r\n            '(c)riteria$'         : '$1riterion',\r\n\r\n            // -ices -> -ex/ix\r\n            '(matr)ices$'    : '$1ix',\r\n            '(vert|ind)ices$': '$1ex',\r\n\r\n            // -oes -> -o\r\n            '(buffal|her|potat|tomat|volcan)oes$': '$1o',\r\n\r\n            // -ouses -> -ouse\r\n            '(h|bl)ouses$': '$1ouse',\r\n            'ouses$'      : 'ouse',\r\n\r\n            // -ies -> -y\r\n            '([^aeiouy]|qu)ies$': '$1y',\r\n\r\n            // -ves -> -f/fe\r\n            '([lr])ves$'             : '$1f',\r\n            '([^fo])ves$'            : '$1fe',\r\n            '(shea|loa|lea|thie)ves$': '$1f',\r\n            '(li|wi|kni)ves$'        : '$1fe',\r\n\r\n            // -es -> -is\r\n            '(analys|ax|cris|test|thes)es$': '$1is',\r\n            '(cris|ax|test)es$'            : '$1is',\r\n\r\n            // -es exceptions\r\n            '(alias|status|bus)es$'         : '$1',\r\n            '(shoe|slave)s$'                : '$1',\r\n            '(corpse)s$'                    : '$1',\r\n            '(drive|dive|hive|olive|tive)s$': '$1',\r\n\r\n            // -xes\r\n            '([ftw]ax)es': '$1',\r\n\r\n            // -ices -> -ouse\r\n            '([m|l])ice$': '$1ouse',\r\n\r\n            // -es -> -e\r\n            '(o)es$'         : '$1',\r\n            '(x|ch|ss|sh)es$': '$1',\r\n\r\n            // -zes -> -ze\r\n            '(quiz)zes$': '$1',\r\n\r\n            // -en -> - (oxen -> ox)\r\n            '^(ox)en$': '$1',\r\n\r\n            // -people -> -person\r\n            '(p)eople$': '$1erson',\r\n\r\n            // Irregular plurals\r\n            '(m)en$'     : '$1an',\r\n            '(c)hildren$': '$1hild',\r\n            '(f)eet$'    : '$1oot',\r\n            '(m)ice$'    : '$1ouse',\r\n            '(t)eeth$'   : '$1ooth',\r\n            '(g)eese$'   : '$1oose',\r\n\r\n            // -news\r\n            '(n)ews$': '$1ews',\r\n\r\n            // -eau\r\n            'eaus$': 'eau',\r\n\r\n            // -ses -> -sis\r\n            '(^analy)ses$'                                                 : '$1sis',\r\n            '((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$': '$1$2sis',\r\n\r\n            // -movies\r\n            '(m)ovies$': '$1ovie',\r\n\r\n            // -series\r\n            '(s)eries$': '$1eries',\r\n\r\n            // -us\r\n            '([^a])uses$': '$1us',\r\n            '(us)es$'    : '$1',\r\n\r\n            // -status\r\n            '(s)tatus(es)?$': '$1tatus',\r\n\r\n            // -campus\r\n            '(c)ampus$': '$1ampus',\r\n\r\n            // General case\r\n            's$': ''\r\n        };\r\n\r\n        // List of words that change irregularly.\r\n        const irregular: Record<string, string> = {\r\n            // A\r\n            'abuses'    : 'abuse',\r\n            'alumnae'   : 'alumna',\r\n            'alumni'    : 'alumnus',\r\n            'analyses'  : 'analysis',\r\n            'appendices': 'appendix',\r\n            'atlases'   : 'atlas',\r\n            'avalanches': 'avalanche',\r\n            'axes'      : 'axis',  // Also covers 'axe'\r\n\r\n            // B\r\n            'bacilli' : 'bacillus',\r\n            'bacteria': 'bacterium',\r\n            'bases'   : 'basis',\r\n            'beaux'   : 'beau',\r\n            'beefs'   : 'beef',\r\n            'blouses' : 'blouse',\r\n            'brothers': 'brother',\r\n            'brownies': 'brownie',\r\n            'bureaux' : 'bureau',\r\n\r\n            // C\r\n            'caches'   : 'cache',\r\n            'cacti'    : 'cactus',\r\n            'cafes'    : 'cafe',\r\n            'calves'   : 'calf',\r\n            'canvases' : 'canvas',\r\n            'caves'    : 'cave',\r\n            'chateaux' : 'chateau',\r\n            'children' : 'child',\r\n            'cookies'  : 'cookie',\r\n            'corpuses' : 'corpus',\r\n            'cows'     : 'cow',\r\n            'crises'   : 'crisis',\r\n            'criteria' : 'criterion',\r\n            'curricula': 'curriculum',\r\n            'curves'   : 'curve',\r\n\r\n            // D\r\n            'deer'     : 'deer',\r\n            'demos'    : 'demo',\r\n            'diagnoses': 'diagnosis',\r\n            'dominoes' : 'domino',\r\n\r\n            // E\r\n            'echoes'  : 'echo',\r\n            'elves'   : 'elf',\r\n            'ellipses': 'ellipsis',\r\n            'emphases': 'emphasis',\r\n            'epochs'  : 'epoch',\r\n\r\n            // F\r\n            'fish'    : 'fish',\r\n            'foci'    : 'focus',\r\n            'foes'    : 'foe',\r\n            'feet'    : 'foot',\r\n            'formulae': 'formula',\r\n            'fungi'   : 'fungus',\r\n\r\n            // G\r\n            'ganglions': 'ganglion',\r\n            'gases'    : 'gas',\r\n            'genies'   : 'genie',\r\n            'genera'   : 'genus',\r\n            'geese'    : 'goose',\r\n            'graffiti' : 'graffito',\r\n            'graves'   : 'grave',\r\n\r\n            // H\r\n            'halves'     : 'half',\r\n            'hippopotami': 'hippopotamus',\r\n            'hoaxes'     : 'hoax',\r\n            'hoofs'      : 'hoof',  // Also acceptable: 'hooves'\r\n            'humans'     : 'human',\r\n\r\n            // I\r\n            'irises': 'iris',\r\n\r\n            // K\r\n            'knives': 'knife',\r\n\r\n            // L\r\n            'larvae': 'larva',\r\n            'leaves': 'leaf',\r\n            'lenses': 'lens',\r\n            'lives' : 'life',\r\n            'loaves': 'loaf',\r\n\r\n            // M\r\n            'men'      : 'man',\r\n            'matrices' : 'matrix',\r\n            'means'    : 'means',\r\n            'media'    : 'medium',\r\n            'memoranda': 'memorandum',\r\n            'monies'   : 'money',\r\n            'mongooses': 'mongoose',\r\n            'mice'     : 'mouse',\r\n            'mottoes'  : 'motto',\r\n            'moves'    : 'move',\r\n            'mythoi'   : 'mythos',\r\n\r\n            // N\r\n            'nebulae' : 'nebula',\r\n            'neuroses': 'neurosis',\r\n            'niches'  : 'niche',\r\n            'niveaux' : 'niveau',\r\n            'nuclei'  : 'nucleus',\r\n            'numina'  : 'numen',\r\n\r\n            // O\r\n            'oases'    : 'oasis',\r\n            'occiputs' : 'occiput',\r\n            'octopuses': 'octopus',\r\n            'offspring': 'offspring',\r\n            'opuses'   : 'opus',\r\n            'oxen'     : 'ox',\r\n\r\n            // P\r\n            'parentheses': 'parenthesis',\r\n            'passersby'  : 'passerby',\r\n            'penises'    : 'penis',\r\n            'people'     : 'person',\r\n            'phenomena'  : 'phenomenon',\r\n            'plateaux'   : 'plateau',\r\n\r\n            // R\r\n            'radii'     : 'radius',\r\n            'runners-up': 'runner-up',\r\n\r\n            // S\r\n            'safes'      : 'safe',\r\n            'saves'      : 'save',\r\n            'scarves'    : 'scarf',\r\n            'selves'     : 'self',\r\n            'series'     : 'series',\r\n            'sexes'      : 'sex',\r\n            'sheep'      : 'sheep',\r\n            'shelves'    : 'shelf',\r\n            'sieves'     : 'sieve',\r\n            'soliloquies': 'soliloquy',\r\n            'sons-in-law': 'son-in-law',\r\n            'species'    : 'species',\r\n            'stadiums'   : 'stadium',\r\n            'stimuli'    : 'stimulus',\r\n            'strata'     : 'stratum',\r\n            'swine'      : 'swine',\r\n            'syllabi'    : 'syllabus',\r\n            'syntheses'  : 'synthesis',\r\n\r\n            // T\r\n            'testes'   : 'testis',\r\n            'theses'   : 'thesis',\r\n            'thieves'  : 'thief',\r\n            'teeth'    : 'tooth',\r\n            'tornadoes': 'tornado',\r\n            'trilbys'  : 'trilby',\r\n            'turfs'    : 'turf',  // Also acceptable: 'turves'\r\n\r\n            // V\r\n            'valves'   : 'valve',\r\n            'volcanoes': 'volcano',\r\n\r\n            // W\r\n            'waves' : 'wave',\r\n            'wives' : 'wife',\r\n            'wolves': 'wolf',\r\n\r\n            // Z\r\n            'zombies': 'zombie'\r\n        };\r\n\r\n        // List of words that do not change.\r\n        const uncountable: Set<string> = new Set([\r\n            // A\r\n            'advice',\r\n            'aircraft',\r\n            'amoyese',\r\n            'art',\r\n            'audio',\r\n\r\n            // B\r\n            'baggage',\r\n            'bison',\r\n            'borghese',\r\n            'bream',\r\n            'breeches',\r\n            'britches',\r\n            'buffalo',\r\n            'butter',\r\n\r\n            // C\r\n            'cantus',\r\n            'carp',\r\n            'cattle',\r\n            'chassis',\r\n            'clippers',\r\n            'clothing',\r\n            'coal',\r\n            'cod',\r\n            'coitus',\r\n            'compensation',\r\n            'congoese',\r\n            'contretemps',\r\n            'coreopsis',\r\n            'corps',\r\n            'cotton',\r\n\r\n            // D\r\n            'data',\r\n            'debris',\r\n            'deer',\r\n            'diabetes',\r\n            'djinn',\r\n\r\n            // E\r\n            'education',\r\n            'eland',\r\n            'elk',\r\n            'emoji',\r\n            'equipment',\r\n            'evidence',\r\n\r\n            // F\r\n            'faroese',\r\n            'feedback',\r\n            'fish',\r\n            'flounder',\r\n            'flour',\r\n            'foochowese',\r\n            'food',\r\n            'furniture',\r\n\r\n            // G\r\n            'gallows',\r\n            'genevese',\r\n            'genoese',\r\n            'gilbertese',\r\n            'gold',\r\n\r\n            // H\r\n            'headquarters',\r\n            'herpes',\r\n            'hijinks',\r\n            'homework',\r\n            'hovercraft',\r\n            'hottentotese',\r\n\r\n            // I\r\n            'impatience',\r\n            'information',\r\n            'innings',\r\n\r\n            // J\r\n            'jackanapes',\r\n            'jeans',\r\n            'jedi',\r\n\r\n            // K\r\n            'kin',\r\n            'kiplingese',\r\n            'knowledge',\r\n            'kongoese',\r\n\r\n            // L\r\n            'leather',\r\n            'love',\r\n            'lucchese',\r\n            'luggage',\r\n\r\n            // M\r\n            'mackerel',\r\n            'Maltese',\r\n            'management',\r\n            'metadata',\r\n            'mews',\r\n            'money',\r\n            'moose',\r\n            'mumps',\r\n            'music',\r\n\r\n            // N\r\n            'nankingese',\r\n            'news',\r\n            'nexus',\r\n            'niasese',\r\n            'nutrition',\r\n\r\n            // O\r\n            'oil',\r\n            'offspring',\r\n\r\n            // P\r\n            'patience',\r\n            'pekingese',\r\n            'piedmontese',\r\n            'pike',\r\n            'pincers',\r\n            'pistoiese',\r\n            'plankton',\r\n            'pliers',\r\n            'pokemon',\r\n            'police',\r\n            'polish',\r\n            'portuguese',\r\n            'proceedings',\r\n            'progress',\r\n\r\n            // Q\r\n            // (none yet)\r\n\r\n            // R\r\n            'rabies',\r\n            'rain',\r\n            'research',\r\n            'rhinoceros',\r\n            'rice',\r\n\r\n            // S\r\n            'salmon',\r\n            'sand',\r\n            'sarawakese',\r\n            'scissors',\r\n            'sea[- ]bass',\r\n            'series',\r\n            'shavese',\r\n            'shears',\r\n            'sheep',\r\n            'shrimp',\r\n            'siemens',\r\n            'silk',\r\n            'sms',\r\n            'soap',\r\n            'social media',\r\n            'spacecraft',\r\n            'spam',\r\n            'species',\r\n            'staff',\r\n            'sugar',\r\n            'swine',\r\n\r\n            // T\r\n            'talent',\r\n            'toothpaste',\r\n            'traffic',\r\n            'travel',\r\n            'trousers',\r\n            'trout',\r\n            'tuna',\r\n\r\n            // U\r\n            'us',\r\n\r\n            // V\r\n            'vermontese',\r\n            'vinegar',\r\n\r\n            // W\r\n            'weather',\r\n            'wenchowese',\r\n            'wheat',\r\n            'whiting',\r\n            'wildebeest',\r\n            'wood',\r\n            'wool',\r\n\r\n            // Y\r\n            'yengeese',\r\n            'you'\r\n        ]);\r\n\r\n        if (uncountable.has(value.toLowerCase())) {\r\n            return matchCase(value, value);\r\n        }\r\n\r\n        for (const word in irregular) {\r\n            const pattern: RegExp = new RegExp(`${word}$`, 'i');\r\n\r\n            if (pattern.test(value)) {\r\n                return matchCase(value.replace(pattern, (irregular[word] as string)), value);\r\n            }\r\n        }\r\n\r\n        for (const word in singular) {\r\n            const pattern: RegExp = new RegExp(word, 'i');\r\n\r\n            if (pattern.test(value)) {\r\n                return matchCase(value.replace(pattern, (singular[word] as string)), value);\r\n            }\r\n        }\r\n\r\n        return matchCase(value, value);\r\n    }\r\n\r\n    /**\r\n     * Generate a URL friendly \"slug\" from a given string.\r\n     *\r\n     * @param { string } title\r\n     * @param { string } separator\r\n     * @param { object } dictionary\r\n     *\r\n     * @return { string }\r\n     */\r\n    static slug(title: string, separator: string = '-', dictionary: Record<string, string> = { '@': 'at' }): string {\r\n        let flip: string = separator === '-' ? '_' : '-';\r\n\r\n        title = title.replace(`![${preg_quote(flip)}]+!u`, separator);\r\n\r\n        for (let value in dictionary) {\r\n            dictionary[value] = separator + dictionary[value] + separator;\r\n        }\r\n\r\n        for (let value in dictionary) {\r\n            title = title.replaceAll(value, (dictionary[value] as string));\r\n        }\r\n\r\n        title = this.lower(title).replace(`![^${preg_quote(separator)}pLpNs]+!u`, '');\r\n\r\n        return title.replaceAll(/\\s/g, separator).replace(new RegExp('\\\\' + separator + '+', 'g'), separator);\r\n    }\r\n\r\n    /**\r\n     * Convert a string to snake case.\r\n     *\r\n     * @param { string } value\r\n     * @param { string } delimiter\r\n     *\r\n     * @return { string }\r\n     */\r\n    static snake(value: string, delimiter: string = '_'): string {\r\n        value = ucwords(value).replace(new RegExp(/\\s+/, 'u'), '');\r\n\r\n        value = this.lower(value.replace(new RegExp(/(.)(?=[A-Z])/, 'ug'), `$1${delimiter}`));\r\n\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Remove all whitespace from both ends of a string.\r\n     *\r\n     * @param { string } value\r\n     * @param { string | null } characters\r\n     *\r\n     * @return { string }\r\n     */\r\n    static trim(value: string, characters: string | null = null): string {\r\n        if (characters === null) {\r\n            return value.trim();\r\n        }\r\n\r\n        if (characters === '') {\r\n            return value;\r\n        }\r\n\r\n        if (characters === ' ') {\r\n            return value.replaceAll(' ', '');\r\n        }\r\n\r\n        characters = characters.split('').join('|');\r\n\r\n        const regex: RegExp = new RegExp(`${characters}+`, 'g');\r\n\r\n        return value.replace(regex, '') ?? value;\r\n    }\r\n\r\n    /**\r\n     * Remove all whitespace from the beginning of a string.\r\n     *\r\n     * @param { string } value\r\n     * @param { string | null } characters\r\n     *\r\n     * @return { string }\r\n     */\r\n    static ltrim(value: string, characters: string | null = null): string {\r\n        if (characters === null) {\r\n            return value.trimStart();\r\n        }\r\n\r\n        if (characters === '') {\r\n            return value;\r\n        }\r\n\r\n        if (characters === ' ') {\r\n            return this.replaceStart(' ', '', value);\r\n        }\r\n\r\n        for (const character of characters.split('')) {\r\n            value = this.replaceStart(character, '', value);\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Remove all whitespace from the end of a string.\r\n     *\r\n     * @param { string } value\r\n     * @param { string | null } characters\r\n     *\r\n     * @return { string }\r\n     */\r\n    static rtrim(value: string, characters: string | null = null): string {\r\n        if (characters === null) {\r\n            return value.trimEnd();\r\n        }\r\n\r\n        if (characters === '') {\r\n            return value;\r\n        }\r\n\r\n        if (characters === ' ') {\r\n            return this.replaceEnd(' ', '', value);\r\n        }\r\n\r\n        for (const character of characters.split('')) {\r\n            value = this.replaceEnd(character, '', value);\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Remove all \"extra\" blank space from the given string.\r\n     *\r\n     * @param { string } value\r\n     *\r\n     * @return { string }\r\n     */\r\n    static squish(value: string): string {\r\n        return value.replace(/\\s\\s+/g, ' ').trim();\r\n    }\r\n\r\n    /**\r\n     * Determine if a given string starts with a given substring.\r\n     *\r\n     * @param { string } haystack\r\n     * @param { string | string[] } needles\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    static startsWith(haystack: string, needles: string | string[]): boolean {\r\n        needles = Array.isArray(needles) ? needles : [needles];\r\n\r\n        for (const needle of needles) {\r\n            if (needle !== '' && haystack.startsWith(needle)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Determine if a given string doesn't start with a given substring.\r\n     *\r\n     * @param { string } haystack\r\n     * @param { string | string[] } needles\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    static doesntStartWith(haystack: string, needles: string | string[]): boolean {\r\n        return !this.startsWith(haystack, needles);\r\n    }\r\n\r\n    /**\r\n     * Convert a value to studly caps case.\r\n     *\r\n     * @param { string } value\r\n     *\r\n     * @return { string }\r\n     */\r\n    static studly(value: string): string {\r\n        const words: string[] = this.replace(['-', '_'], ' ', value).split(' ');\r\n\r\n        const studlyWords: string[] = words.map((word: string): string => this.ucfirst(word));\r\n\r\n        return studlyWords.join('');\r\n    }\r\n\r\n    /**\r\n     * Convert a value to Pascal case.\r\n     *\r\n     * @param { string } value\r\n     *\r\n     * @return { string }\r\n     */\r\n    static pascal(value: string): string {\r\n        return this.studly(value);\r\n    }\r\n\r\n    /**\r\n     * Returns the portion of the string specified by the start and length parameters.\r\n     *\r\n     * @param { string } string\r\n     * @param { number } start\r\n     * @param { number | null } length\r\n     *\r\n     * @return { string }\r\n     */\r\n    static substr(string: string, start: number, length: number | null = null): string {\r\n        if (start < 0) {\r\n            start = string.length + start;\r\n\r\n            if (start < 0) {\r\n                start = 0;\r\n            }\r\n        }\r\n\r\n        if (length !== null && length <= 0) {\r\n            return '';\r\n        }\r\n\r\n        if (length === null || length === 0) {\r\n            return string.substring(start, string.length);\r\n        }\r\n\r\n        return string.substring(start, start + length);\r\n    }\r\n\r\n    /**\r\n     * Returns the number of substring occurrences.\r\n     *\r\n     * @param { string } haystack\r\n     * @param { string } needle\r\n     * @param { number } offset\r\n     * @param { number | null } length\r\n     *\r\n     * @return { number }\r\n     */\r\n    static substrCount(haystack: string, needle: string, offset: number = 0, length: number | null = null): number {\r\n        if (length) {\r\n            return haystack.substring(offset).substring(0, length).split(needle).length - 1;\r\n        }\r\n\r\n        return haystack.substring(offset).split(needle).length - 1;\r\n    }\r\n\r\n    /**\r\n     * Replace text within a portion of a string.\r\n     *\r\n     * @param { string } string\r\n     * @param { string } replace\r\n     * @param { number } offset\r\n     * @param { number | null } length\r\n     *\r\n     * @return { string }\r\n     */\r\n    static substrReplace(string: string, replace: string, offset: number = 0, length: number | null = null): string {\r\n        if (length !== null) {\r\n            return string.substring(0, offset) + replace + string.substring(offset);\r\n        }\r\n\r\n        return string.substring(0, offset) + replace;\r\n    }\r\n\r\n    /**\r\n     * Swap multiple keywords in a string with other keywords.\r\n     *\r\n     * @param { object } map\r\n     * @param { string } subject\r\n     *\r\n     * @return { string }\r\n     */\r\n    static swap(map: Record<string, string>, subject: string): string {\r\n        for (const value in map) {\r\n            subject = subject.replace(value, (map[value] as string));\r\n        }\r\n\r\n        return subject;\r\n    }\r\n\r\n    /**\r\n     * Take the first or last {limit} characters of a string.\r\n     *\r\n     * @param { string } string\r\n     * @param { number } limit\r\n     *\r\n     * @return { string }\r\n     */\r\n    static take(string: string, limit: number): string {\r\n        if (limit < 0) {\r\n            return this.substr(string, limit);\r\n        }\r\n\r\n        return this.substr(string, 0, limit);\r\n    }\r\n\r\n    /**\r\n     * Convert the given string to Base64 encoding.\r\n     *\r\n     * @param { string } string\r\n     *\r\n     * @return { string }\r\n     */\r\n    static toBase64(string: string): string {\r\n        return btoa(string);\r\n    }\r\n\r\n    /**\r\n     * Decode the given Base64 encoded string.\r\n     *\r\n     * @param { string } string\r\n     *\r\n     * @return { string }\r\n     */\r\n    static fromBase64(string: string): string {\r\n        return atob(string);\r\n    }\r\n\r\n    /**\r\n     * Make a string's first character lowercase.\r\n     *\r\n     * @param { string } string\r\n     *\r\n     * @return { string }\r\n     */\r\n    static lcfirst(string: string): string {\r\n        return this.lower(this.substr(string, 0, 1)) + this.substr(string, 1, string.length);\r\n    }\r\n\r\n    /**\r\n     * Make a string's first character uppercase.\r\n     *\r\n     * @param { string } string\r\n     *\r\n     * @return { string }\r\n     */\r\n    static ucfirst(string: string): string {\r\n        return this.upper(this.substr(string, 0, 1)) + this.substr(string, 1, string.length);\r\n    }\r\n\r\n    /**\r\n     * Capitalize the first character of each word in a string.\r\n     *\r\n     * @param { string } string\r\n     * @param { string } separators\r\n     *\r\n     * @return { string }\r\n     */\r\n    static ucwords(string: string, separators: string = ' \\t\\r\\n\\f\\v'): string {\r\n        const pattern: RegExp = new RegExp(`(^|[${preg_quote(separators, '/')}])(\\\\p{Ll})`, 'gu');\r\n\r\n        return string.replace(pattern, (match: string): string => match.toUpperCase());\r\n    }\r\n\r\n    /**\r\n     * Split a string into pieces by uppercase characters.\r\n     *\r\n     * @param { string } string\r\n     *\r\n     * @return { string[] }\r\n     */\r\n    static ucsplit(string: string): string[] {\r\n        return string.split(new RegExp(/(?=\\p{Lu})/u));\r\n    }\r\n\r\n    /**\r\n     * Get the number of words a string contains.\r\n     *\r\n     * @param { string } string\r\n     *\r\n     * @return { number }\r\n     */\r\n    static wordCount(string: string): number {\r\n        return string.split(/\\s+/).length;\r\n    }\r\n\r\n    /**\r\n     * Wrap a string to a given number of characters.\r\n     *\r\n     * @param { string } string\r\n     * @param { number } characters\r\n     * @param { string } breakStr\r\n     * @param { boolean } cutLongWords\r\n     *\r\n     * @returns { string }\r\n     */\r\n    static wordWrap(string: string, characters: number = 75, breakStr: string = '\\n', cutLongWords: boolean = false): string {\r\n        const breakWithSpace: string = cutLongWords ? breakStr + '\\u00ad' : breakStr;\r\n        const regex: RegExp = new RegExp(`.{1,${characters}}`, 'g');\r\n        const result: string = string.replace(regex, (substr: string): string => substr.trim() + breakWithSpace);\r\n\r\n        return this.replaceLast(breakStr, '', result);\r\n    }\r\n\r\n    /**\r\n     * Generate a UUID (version 4).\r\n     *\r\n     * @return { string }\r\n     */\r\n    static uuid(): string {\r\n        if (this.uuidFactory !== null) {\r\n            return this.uuidFactory();\r\n        }\r\n\r\n        let time: number = Number.parseInt((Math.random() * Number.MAX_SAFE_INTEGER + 1).toString().substring(0, 13));\r\n\r\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (character: string): string {\r\n            let randomChar: number = Math.trunc((time + Math.random() * 16) % 16);\r\n            time = Math.floor(time / 16);\r\n\r\n            return (character === 'x' ? randomChar : (randomChar & 0x3 | 0x8)).toString(16);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Generate a UUID (version 7).\r\n     *\r\n     * @return { string }\r\n     */\r\n    static uuid7(time: Date | null = null): string {\r\n        if (this.uuidFactory !== null) {\r\n            return this.uuidFactory();\r\n        }\r\n\r\n        const values = new Uint32Array(3);\r\n\r\n        crypto.getRandomValues(values);\r\n\r\n        const timestamp: number = time ? time.getTime() : Date.now();\r\n\r\n        if (timestamp < 0 || timestamp > 281474976710655) {\r\n            throw new RangeError('Timestamp must be a 48-bit positive integer');\r\n        }\r\n\r\n        const [r1, r2, r3] = values;\r\n\r\n        const randomA: number = (r1 as number) & 0xfff;\r\n        const randomBHi: number = (r2 as number) & 0x3fffffff;\r\n        const randomBLo: number = r3 as number;\r\n\r\n        const bytes = new Uint8Array(16);\r\n\r\n        bytes[0] = timestamp / 2 ** 40;\r\n        bytes[1] = timestamp / 2 ** 32;\r\n        bytes[2] = timestamp / 2 ** 24;\r\n        bytes[3] = timestamp / 2 ** 16;\r\n        bytes[4] = timestamp / 2 ** 8;\r\n        bytes[5] = timestamp;\r\n        bytes[6] = 0x70 | (randomA >>> 8);\r\n        bytes[7] = randomA;\r\n        bytes[8] = 0x80 | (randomBHi >>> 24);\r\n        bytes[9] = randomBHi >>> 16;\r\n        bytes[10] = randomBHi >>> 8;\r\n        bytes[11] = randomBHi;\r\n        bytes[12] = randomBLo >>> 24;\r\n        bytes[13] = randomBLo >>> 16;\r\n        bytes[14] = randomBLo >>> 8;\r\n        bytes[15] = randomBLo;\r\n\r\n        const digits = '0123456789abcdef';\r\n\r\n        let result: string = '';\r\n\r\n        for (let i: number = 0; i < 16; i++) {\r\n            result += digits.charAt(bytes[i]! >>> 4);\r\n            result += digits.charAt(bytes[i]! & 0xf);\r\n\r\n            if (i === 3 || i === 5 || i === 7 || i === 9) {\r\n                result += '-';\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Generate a time-ordered UUID (version 4).\r\n     *\r\n     * @return { string }\r\n     */\r\n    static orderedUuid(): string {\r\n        if (this.uuidFactory !== null) {\r\n            return this.uuidFactory();\r\n        }\r\n\r\n        let time: number = Date.now();\r\n\r\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (character: string): string {\r\n            let randomChar: number = Math.trunc((time + Math.random() * 16) % 16);\r\n            time = Math.floor(time / 16);\r\n\r\n            return (character === 'x' ? randomChar : (randomChar & 0x3 | 0x8)).toString(16);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Set the callable that will be used to generate UUIDs.\r\n     *\r\n     * @param { Function | null } factory\r\n     *\r\n     * @return { void }\r\n     */\r\n    static createUuidsUsing(factory: Function | null = null): void {\r\n        this.uuidFactory = factory;\r\n    }\r\n\r\n    /**\r\n     * Set the sequence that will be used to generate random strings.\r\n     *\r\n     * @param { (string | undefined)[] } sequence\r\n     * @param { Function | null } whenMissing\r\n     *\r\n     * @return { void }\r\n     */\r\n    static createUuidsUsingSequence(sequence: (string | undefined)[], whenMissing: Function | null = null): void {\r\n        let next: number = 0;\r\n\r\n        whenMissing ??= (): string => {\r\n            const factoryCache: Function | null = this.uuidFactory;\r\n\r\n            this.uuidFactory = null;\r\n\r\n            const uuid: string = this.uuid();\r\n\r\n            this.uuidFactory = factoryCache;\r\n\r\n            next++;\r\n\r\n            return uuid;\r\n        };\r\n\r\n        this.createUuidsUsing(() => {\r\n            if (sequence[next] !== undefined) {\r\n                return sequence[next++];\r\n            }\r\n\r\n            return whenMissing();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Always return the same UUID when generating new UUIDs.\r\n     *\r\n     * @param { Function | null } callback\r\n     *\r\n     * @return { string }\r\n     */\r\n    static freezeUuids(callback: Function | null = null): string {\r\n        const uuid: string = this.uuid();\r\n\r\n        this.createUuidsUsing((): string => uuid);\r\n\r\n        if (callback !== null) {\r\n            try {\r\n                callback(uuid);\r\n            } finally {\r\n                this.createUuidsNormally();\r\n            }\r\n        }\r\n\r\n        return uuid;\r\n    }\r\n\r\n    /**\r\n     * Indicate that UUIDs should be created normally and not using a custom factory.\r\n     *\r\n     * @return { void }\r\n     */\r\n    static createUuidsNormally(): void {\r\n        this.uuidFactory = null;\r\n    }\r\n\r\n    /**\r\n     * Generate a ULID.\r\n     *\r\n     * @return { string }\r\n     */\r\n    static ulid(): string {\r\n        if (this.ulidFactory !== null) {\r\n            return this.ulidFactory();\r\n        }\r\n\r\n        const encoding: string = '0123456789ABCDEFGHJKMNPQRSTVWXYZ';\r\n        const encodingLength: number = encoding.length;\r\n        const timeLength: number = 10;\r\n        const randomLength: number = 16;\r\n\r\n        /**\r\n         * Generate random Encoding Time.\r\n         *\r\n         * @return { string }\r\n         */\r\n        function generateEncodedTime(): string {\r\n            let encodedTime: string = '';\r\n            let now: number = Date.now();\r\n\r\n            for (let length: number = timeLength; length > 0; length--) {\r\n                const mod: number = now % encodingLength;\r\n                encodedTime = encoding.charAt(mod) + encodedTime;\r\n\r\n                now = (now - mod) / encodingLength;\r\n            }\r\n\r\n            return encodedTime;\r\n        }\r\n\r\n        /**\r\n         * Generate random Number.\r\n         *\r\n         * @return { number }\r\n         */\r\n        function generateRandomNumber(): number {\r\n            const buffer: Uint8Array = new Uint8Array(1);\r\n\r\n            crypto.getRandomValues(buffer);\r\n\r\n            return (buffer[0] as number) / 0xff;\r\n        }\r\n\r\n        /**\r\n         * Generate random String.\r\n         *\r\n         * @return { string }\r\n         */\r\n        function generateRandomString(): string {\r\n            let string: string = '';\r\n\r\n            for (let length: number = randomLength; length > 0; length--) {\r\n                let randomNumber: number = Math.floor(generateRandomNumber() * encodingLength);\r\n\r\n                if (randomNumber === encodingLength) {\r\n                    randomNumber = encodingLength - 1;\r\n                }\r\n\r\n                string += encoding.charAt(randomNumber);\r\n            }\r\n\r\n            return string;\r\n        }\r\n\r\n        return generateEncodedTime() + generateRandomString();\r\n    }\r\n\r\n    /**\r\n     * Set the callable that will be used to generate ULIDs.\r\n     *\r\n     * @param { Function | null } factory\r\n     *\r\n     * @return { void }\r\n     */\r\n    static createUlidsUsing(factory: Function | null = null): void {\r\n        this.ulidFactory = factory;\r\n    }\r\n\r\n    /**\r\n     * Set the sequence that will be used to generate ULIDs.\r\n     *\r\n     * @param { (string | undefined)[] } sequence\r\n     * @param { Function | null } whenMissing\r\n     *\r\n     * @return { void }\r\n     */\r\n    static createUlidsUsingSequence(sequence: (string | undefined)[], whenMissing: Function | null = null): void {\r\n        let next: number = 0;\r\n\r\n        whenMissing ??= (): string => {\r\n            const factoryCache: Function | null = this.ulidFactory;\r\n\r\n            this.ulidFactory = null;\r\n\r\n            const ulid: string = this.ulid();\r\n\r\n            this.ulidFactory = factoryCache;\r\n\r\n            next++;\r\n\r\n            return ulid;\r\n        };\r\n\r\n        this.createUlidsUsing(() => {\r\n            if (sequence[next] !== undefined) {\r\n                return sequence[next++];\r\n            }\r\n\r\n            return whenMissing();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Always return the same UUID when generating new UUIDs.\r\n     *\r\n     * @param { Function | null } callback\r\n     *\r\n     * @return { string }\r\n     */\r\n    static freezeUlids(callback: Function | null = null): string {\r\n        const ulid: string = this.ulid();\r\n\r\n        this.createUlidsUsing(() => ulid);\r\n\r\n        if (callback !== null) {\r\n            try {\r\n                callback(ulid);\r\n            } finally {\r\n                this.createUlidsNormally();\r\n            }\r\n        }\r\n\r\n        return ulid;\r\n    }\r\n\r\n    /**\r\n     * Indicate that ULIDs should be created normally and not using a custom factory.\r\n     *\r\n     * @return { void }\r\n     */\r\n    static createUlidsNormally(): void {\r\n        this.ulidFactory = null;\r\n    }\r\n\r\n    /**\r\n     * Convert the given value to a string or return the given fallback on failure.\r\n     *\r\n     * @param { * } value\r\n     * @param { string } fallback\r\n     *\r\n     * @return { string }\r\n     */\r\n    private static toStringOr(value: any, fallback: string): string {\r\n        if (value === null || value === undefined || typeof value === 'object' || typeof value === 'function') {\r\n            return fallback;\r\n        }\r\n\r\n        return String(value);\r\n    }\r\n}\r\n\r\n/**\r\n * @typedef Value\r\n * @type { Stringable | boolean | ((instance: Stringable) => Stringable|boolean) }\r\n *\r\n * @typedef Callback\r\n * @type { (instance: Stringable, value: boolean) => Stringable | void | undefined }\r\n *\r\n * @typedef Fallback\r\n * @type { Callback | null }\r\n */\r\nexport class Stringable {\r\n    /**\r\n     * The underlying string value.\r\n     *\r\n     * @private\r\n     *\r\n     * @type { string }\r\n     */\r\n    readonly #value: string;\r\n\r\n    /**\r\n     * Create a new instance of the class.\r\n     *\r\n     * @param { string } value\r\n     */\r\n    constructor(value: string = '') {\r\n        this.#value = value;\r\n    }\r\n\r\n    /**\r\n     * Return the remainder of a string after the first occurrence of a given value.\r\n     *\r\n     * @param { string } search\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    after(search: string): Stringable {\r\n        return new Stringable(Str.after(this.#value, search));\r\n    }\r\n\r\n    /**\r\n     * Return the remainder of a string after the last occurrence of a given value.\r\n     *\r\n     * @param { string } search\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    afterLast(search: string): Stringable {\r\n        return new Stringable(Str.afterLast(this.#value, search));\r\n    }\r\n\r\n    /**\r\n     * Append the given values to the string.\r\n     *\r\n     * @param { string | string[] } values\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    append(...values: string[]): Stringable {\r\n        return new Stringable(this.#value + values.join(''));\r\n    }\r\n\r\n    /**\r\n     * Append a new line to the string.\r\n     *\r\n     * @param { number } count\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    newLine(count: number = 1): Stringable {\r\n        return this.append('\\n'.repeat(count));\r\n    }\r\n\r\n    /**\r\n     * Transliterate a UTF-8 value to ASCII.\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    ascii(): Stringable {\r\n        return new Stringable(Str.ascii(this.#value));\r\n    }\r\n\r\n    /**\r\n     * Get the trailing name component of the path.\r\n     *\r\n     * @param { string } suffix\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    basename(suffix: string = ''): Stringable {\r\n        let basename: string = this.#value;\r\n\r\n        if (this.#value.split('/')[0] !== this.#value) {\r\n            basename = (this.#value.split('/').pop() as string);\r\n        }\r\n\r\n        if (this.#value.split('\\\\')[0] !== this.#value) {\r\n            basename = (this.#value.split('\\\\').pop() as string);\r\n        }\r\n\r\n        if (suffix !== '') {\r\n            basename = basename.replace(suffix, '');\r\n        }\r\n\r\n        return new Stringable(basename);\r\n    }\r\n\r\n    /**\r\n     * Get the character at the specified index.\r\n     *\r\n     * @param { number } index\r\n     *\r\n     * @return { string | false }\r\n     */\r\n    charAt(index: number): string | false {\r\n        return Str.charAt(this.#value, index);\r\n    }\r\n\r\n    /**\r\n     * Remove the given string if it exists at the start of the current string.\r\n     *\r\n     * @param { string | string[] }  needle\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    chopStart(needle: string | string[]): Stringable {\r\n        return new Stringable(Str.chopStart(this.#value, needle));\r\n    }\r\n\r\n    /**\r\n     * Remove the given string if it exists at the end of the current string.\r\n     *\r\n     * @param { string | string[] }  needle\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    chopEnd(needle: string | string[]): Stringable {\r\n        return new Stringable(Str.chopEnd(this.#value, needle));\r\n    }\r\n\r\n    /**\r\n     * Get the basename of the class path.\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    classBasename(): Stringable {\r\n        return this.basename();\r\n    }\r\n\r\n    /**\r\n     * Get the portion of a string before the first occurrence of a given value.\r\n     *\r\n     * @param { string } search\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    before(search: string): Stringable {\r\n        return new Stringable(Str.before(this.#value, search));\r\n    }\r\n\r\n    /**\r\n     * Get the portion of a string before the last occurrence of a given value.\r\n     *\r\n     * @param { string } search\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    beforeLast(search: string): Stringable {\r\n        return new Stringable(Str.beforeLast(this.#value, search));\r\n    }\r\n\r\n    /**\r\n     * Get the portion of a string between two given values.\r\n     *\r\n     * @param { string } from\r\n     * @param { string } to\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    between(from: string, to: string): Stringable {\r\n        return new Stringable(Str.between(this.#value, from, to));\r\n    }\r\n\r\n    /**\r\n     * Get the smallest possible portion of a string between two given values.\r\n     *\r\n     * @param { string } from\r\n     * @param { string } to\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    betweenFirst(from: string, to: string): Stringable {\r\n        return new Stringable(Str.betweenFirst(this.#value, from, to));\r\n    }\r\n\r\n    /**\r\n     * Convert a value to camel case.\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    camel(): Stringable {\r\n        return new Stringable(Str.camel(this.#value));\r\n    }\r\n\r\n    /**\r\n     * Determine if a given string contains a given substring.\r\n     *\r\n     * @param  { string | string[] } needles\r\n     * @param  { boolean } ignoreCase\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    contains(needles: string | string[], ignoreCase: boolean = false): boolean {\r\n        return Str.contains(this.#value, needles, ignoreCase);\r\n    }\r\n\r\n    /**\r\n     * Determine if a given string contains all array values.\r\n     *\r\n     * @param { string[] } needles\r\n     * @param { boolean } ignoreCase\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    containsAll(needles: string[], ignoreCase: boolean = false): boolean {\r\n        return Str.containsAll(this.#value, needles, ignoreCase);\r\n    }\r\n\r\n    /**\r\n     * Determine if a given string doesn't contain a given substring.\r\n     *\r\n     * @param  { string | string[] } needles\r\n     * @param  { boolean } ignoreCase\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    doesntContain(needles: string | string[], ignoreCase: boolean = false): boolean {\r\n        return !this.contains(needles, ignoreCase);\r\n    }\r\n\r\n    /**\r\n     * Convert the case of a string.\r\n     *\r\n     * @param { Mode | number } mode\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    convertCase(mode: Mode | number = Mode.MB_CASE_FOLD): Stringable {\r\n        return new Stringable(Str.convertCase(this.#value, mode));\r\n    }\r\n\r\n    /**\r\n     * Replace consecutive instances of a given character with a single character in the given string.\r\n     *\r\n     * @param { string | string[] } characters\r\n     *\r\n     * @return { string }\r\n     */\r\n    deduplicate(characters: string | string[] = ' '): Stringable {\r\n        return new Stringable(Str.deduplicate(this.#value, characters));\r\n    }\r\n\r\n    /**\r\n     * Get the parent directory's path.\r\n     *\r\n     * @param { number } levels\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    dirname(levels: number = 1): Stringable {\r\n        const separator: string = this.#value.includes('/') ? '/' : '\\\\';\r\n        let parts: string[] = this.#value.split(separator);\r\n\r\n        if (parts.length <= levels) {\r\n            if (this.#value.startsWith(separator)) {\r\n                return new Stringable(separator);\r\n            }\r\n\r\n            if (this.#value.match(/^[a-zA-Z]:\\\\/)) {\r\n                return new Stringable(parts[0] + '\\\\');\r\n            }\r\n\r\n            return new Stringable('.');\r\n        }\r\n\r\n        let dirname: string = parts.slice(0, -levels).join(separator);\r\n\r\n        if (!dirname) {\r\n            dirname = separator;\r\n        }\r\n\r\n        if (separator === '\\\\' && dirname.endsWith(':')) {\r\n            dirname += '\\\\';\r\n        }\r\n\r\n        return new Stringable(dirname);\r\n    }\r\n\r\n    /**\r\n     * Determine if a given string ends with a given substring.\r\n     *\r\n     * @param { string | string[] } needles\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    endsWith(needles: string | string[]): boolean {\r\n        return Str.endsWith(this.#value, needles);\r\n    }\r\n\r\n    /**\r\n     * Determine if a given string doesn't end with a given substring.\r\n     *\r\n     * @param { string | string[] } needles\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    doesntEndWith(needles: string | string[]): boolean {\r\n        return !this.endsWith(needles);\r\n    }\r\n\r\n    /**\r\n     * Determine if the string is an exact match with the given value.\r\n     *\r\n     * @param { Stringable | string } value\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    exactly(value: Stringable | string): boolean {\r\n        if (value instanceof Stringable) {\r\n            value = value.toString();\r\n        }\r\n\r\n        return this.#value === value;\r\n    }\r\n\r\n    /**\r\n     * Extracts an excerpt from text that matches the first instance of a phrase.\r\n     *\r\n     * @param { string } phrase\r\n     * @param { ExcerptOptions } options\r\n     *\r\n     * @return { string | null }\r\n     */\r\n    excerpt(phrase: string = '', options: ExcerptOptions = {}): string | null {\r\n        return Str.excerpt(this.#value, phrase, options);\r\n    }\r\n\r\n    /**\r\n     * Explode the string into an array.\r\n     *\r\n     * @param { string } delimiter\r\n     * @param { number } limit\r\n     *\r\n     * @return { string[] }\r\n     */\r\n    explode(delimiter: string, limit: number = 0): string[] {\r\n        let wordsArray: string[] = this.#value.split(delimiter);\r\n\r\n        const position: number = limit - 1 >= wordsArray.length\r\n            ? wordsArray.length - 1\r\n            : limit - 1;\r\n\r\n        wordsArray = [...wordsArray.slice(0, position), wordsArray.splice(position).join(' ')];\r\n\r\n        return wordsArray;\r\n    }\r\n\r\n    /**\r\n     * Split a string using a regular expression or by length.\r\n     *\r\n     * @param { RegExp | number } pattern\r\n     * @param { number } limit\r\n     *\r\n     * @return { string[] }\r\n     */\r\n    split(pattern: RegExp | number, limit: number = -1): string[] {\r\n        if (typeof pattern === 'number') {\r\n            return [...(this.#value.trim().match(new RegExp(`.{1,${pattern}}`, 'g')) ?? [])];\r\n        }\r\n\r\n        const flags: string = [...new Set([...(pattern.toString().match(/[gimsuy]/g) || []), 'g'])].join('');\r\n        const expression: RegExp = new RegExp(pattern, flags);\r\n\r\n        let segments: string[] = this.#value.trim().split(expression);\r\n\r\n        if (limit > 0) {\r\n            const position: number = limit - 1 >= segments.length\r\n                ? segments.length - 1\r\n                : limit - 1;\r\n\r\n            segments = [...segments.slice(0, position), segments.splice(position).join(' ')];\r\n        }\r\n\r\n        return segments.map((segment: string): string => segment.trim()) ?? [];\r\n    }\r\n\r\n    /**\r\n     * Cap a string with a single instance of a given value.\r\n     *\r\n     * @param { string } cap\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    finish(cap: string): Stringable {\r\n        return new Stringable(Str.finish(this.#value, cap));\r\n    }\r\n\r\n    /**\r\n     * Determine if a given string matches a given pattern.\r\n     *\r\n     * @param { string | string[] } pattern\r\n     * @param { boolean } ignoreCase\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    is(pattern: string | string[], ignoreCase: boolean = false): boolean {\r\n        return Str.is(pattern, this.#value, ignoreCase);\r\n    }\r\n\r\n    /**\r\n     * Determine if a given string is 7-bit ASCII.\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    isAscii(): boolean {\r\n        return Str.isAscii(this.#value);\r\n    }\r\n\r\n    /**\r\n     * Determine if a given string is valid JSON.\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    isJson(): boolean {\r\n        return Str.isJson(this.#value);\r\n    }\r\n\r\n    /**\r\n     * Determine if a given value is a valid URL.\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    isUrl(): boolean {\r\n        return Str.isUrl(this.#value);\r\n    }\r\n\r\n    /**\r\n     * Determine if a given string is a valid UUID.\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    isUuid(): boolean {\r\n        return Str.isUuid(this.#value);\r\n    }\r\n\r\n    /**\r\n     * Determine if a given string is a valid ULID.\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    isUlid(): boolean {\r\n        return Str.isUlid(this.#value);\r\n    }\r\n\r\n    /**\r\n     * Determine if the given string is empty.\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    isEmpty(): boolean {\r\n        return this.#value.trim() === '';\r\n    }\r\n\r\n    /**\r\n     * Determine if the given string is not empty.\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    isNotEmpty(): boolean {\r\n        return !this.isEmpty();\r\n    }\r\n\r\n    /**\r\n     * Convert a string to kebab case.\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    kebab(): Stringable {\r\n        return new Stringable(Str.kebab(this.#value));\r\n    }\r\n\r\n    /**\r\n     * Return the length of the given string.\r\n     *\r\n     * @return { number }\r\n     */\r\n    length(): number {\r\n        return Str.length(this.#value);\r\n    }\r\n\r\n    /**\r\n     * Limit the number of characters in a string.\r\n     *\r\n     * @param { number } limit\r\n     * @param { string } end\r\n     * @param { boolean } preserveWords\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    limit(limit: number = 100, end: string = '...', preserveWords: boolean = false): Stringable {\r\n        return new Stringable(Str.limit(this.#value, limit, end, preserveWords));\r\n    }\r\n\r\n    /**\r\n     * Convert the given string to lower-case.\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    lower(): Stringable {\r\n        return new Stringable(Str.lower(this.#value));\r\n    }\r\n\r\n    /**\r\n     * Masks a portion of a string with a repeated character.\r\n     *\r\n     * @param { string } character\r\n     * @param { number } index\r\n     * @param { number | null }length\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    mask(character: string, index: number, length: number | null = null): Stringable {\r\n        return new Stringable(Str.mask(this.#value, character, index, length));\r\n    }\r\n\r\n    /**\r\n     * Get the string matching the given pattern.\r\n     *\r\n     * @param { RegExp } pattern\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    match(pattern: RegExp): Stringable {\r\n        return new Stringable(Str.match(pattern, this.#value));\r\n    }\r\n\r\n    /**\r\n     * Determine if a given string matches a given pattern.\r\n     *\r\n     * @param { RegExp | RegExp[] } pattern\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    isMatch(...pattern: RegExp[]): boolean {\r\n        return Str.isMatch(pattern, this.#value);\r\n    }\r\n\r\n    /**\r\n     * Get the string matching the given pattern.\r\n     *\r\n     * @param { RegExp } pattern\r\n     *\r\n     * @return { string[] }\r\n     */\r\n    matchAll(pattern: RegExp): string[] {\r\n        return Str.matchAll(pattern, this.#value);\r\n    }\r\n\r\n    /**\r\n     * Determine if the string matches the given pattern.\r\n     *\r\n     * @param { RegExp } pattern\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    test(pattern: RegExp): boolean {\r\n        return this.match(pattern).isNotEmpty();\r\n    }\r\n\r\n    /**\r\n     * Remove all non-numeric characters from a string.\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    numbers(): Stringable {\r\n        return new Stringable(Str.numbers(this.#value));\r\n    }\r\n\r\n    /**\r\n     * Pad both sides of the string with another.\r\n     *\r\n     * @param { number } length\r\n     * @param { string } pad\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    padBoth(length: number, pad: string = ' '): Stringable {\r\n        return new Stringable(Str.padBoth(this.#value, length, pad));\r\n    }\r\n\r\n    /**\r\n     * Pad the left side of the string with another.\r\n     *\r\n     * @param { number } length\r\n     * @param { string } pad\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    padLeft(length: number, pad: string = ' '): Stringable {\r\n        return new Stringable(Str.padLeft(this.#value, length, pad));\r\n    }\r\n\r\n    /**\r\n     * Pad the right side of the string with another.\r\n     *\r\n     * @param { number } length\r\n     * @param { string } pad\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    padRight(length: number, pad: string = ' '): Stringable {\r\n        return new Stringable(Str.padRight(this.#value, length, pad));\r\n    }\r\n\r\n    /**\r\n     * Call the given callback and return a new string.\r\n     *\r\n     * @param { keyof string | ((instance: this) => any) } callback\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    pipe(callback: keyof string | ((instance: this) => any)): Stringable {\r\n        if (typeof callback === 'string') {\r\n            if (typeof (this.#value as any)[callback] === 'function') {\r\n                return new Stringable((this.#value as any)[callback]());\r\n            }\r\n        }\r\n\r\n        return new Stringable((callback as (instance: this) => any)(this).toString());\r\n    }\r\n\r\n    /**\r\n     * Get the plural form of an English word.\r\n     *\r\n     * @param { number } count\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    plural(count: number = 2): Stringable {\r\n        return new Stringable(Str.plural(this.#value, count));\r\n    }\r\n\r\n    /**\r\n     * Pluralize the last word of an English, studly caps case string.\r\n     *\r\n     * @param { number } count\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    pluralStudly(count: number = 2): Stringable {\r\n        return new Stringable(Str.pluralStudly(this.#value, count));\r\n    }\r\n\r\n    /**\r\n     * Pluralize the last word of an English, Pascal case string.\r\n     *\r\n     * @param { number } count\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    pluralPascal(count: number = 2): Stringable {\r\n        return new Stringable(Str.pluralPascal(this.#value, count));\r\n    }\r\n\r\n    /**\r\n     * Find the multibyte safe position of the first occurrence of the given substring.\r\n     *\r\n     * @param { string } needle\r\n     * @param { number } offset\r\n     *\r\n     * @return { number | false }\r\n     */\r\n    position(needle: string, offset: number = 0): number | false {\r\n        return Str.position(this.#value, needle, offset);\r\n    }\r\n\r\n    /**\r\n     * Prepend the given values to the string.\r\n     *\r\n     * @param { string | string[] } values\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    prepend(...values: string[]): Stringable {\r\n        return new Stringable(values.join('') + this.#value);\r\n    }\r\n\r\n    /**\r\n     * Remove any occurrence of the given string in the subject.\r\n     *\r\n     * @param { string | string[] } search\r\n     * @param { boolean } caseSensitive\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    remove(search: string | string[], caseSensitive: boolean = true): Stringable {\r\n        return new Stringable(Str.remove(search, this.#value, caseSensitive));\r\n    }\r\n\r\n    /**\r\n     * Reverse the string.\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    reverse(): Stringable {\r\n        return new Stringable(Str.reverse(this.#value));\r\n    }\r\n\r\n    /**\r\n     * Repeat the string.\r\n     *\r\n     * @param { number } times\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    repeat(times: number): Stringable {\r\n        return new Stringable(Str.repeat(this.#value, times));\r\n    }\r\n\r\n    /**\r\n     * Replace the given value in the given string.\r\n     *\r\n     * @param { string | string[] } search\r\n     * @param { string | string[] } replace\r\n     * @param { boolean } caseSensitive\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    replace(search: string | string[], replace: string | string[], caseSensitive: boolean = true): Stringable {\r\n        return new Stringable(Str.replace(search, replace, this.#value, caseSensitive));\r\n    }\r\n\r\n    /**\r\n     * Replace a given value in the string sequentially with an array.\r\n     *\r\n     * @param { string } search\r\n     * @param { string[] } replace\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    replaceArray(search: string, replace: string[]): Stringable {\r\n        return new Stringable(Str.replaceArray(search, replace, this.#value));\r\n    }\r\n\r\n    /**\r\n     * Replace the first occurrence of a given value in the string.\r\n     *\r\n     * @param { string } search\r\n     * @param { string } replace\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    replaceFirst(search: string, replace: string): Stringable {\r\n        return new Stringable(Str.replaceFirst(search, replace, this.#value));\r\n    }\r\n\r\n    /**\r\n     * Replace the first occurrence of the given value if it appears at the start of the string.\r\n     *\r\n     * @param { string } search\r\n     * @param { string } replace\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    replaceStart(search: string, replace: string): Stringable {\r\n        return new Stringable(Str.replaceStart(search, replace, this.#value));\r\n    }\r\n\r\n    /**\r\n     * Replace the last occurrence of a given value in the string.\r\n     *\r\n     * @param { string } search\r\n     * @param { string } replace\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    replaceLast(search: string, replace: string): Stringable {\r\n        return new Stringable(Str.replaceLast(search, replace, this.#value));\r\n    }\r\n\r\n    /**\r\n     * Replace the last occurrence of a given value if it appears at the end of the string.\r\n     *\r\n     * @param { string } search\r\n     * @param { string } replace\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    replaceEnd(search: string, replace: string): Stringable {\r\n        return new Stringable(Str.replaceEnd(search, replace, this.#value));\r\n    }\r\n\r\n    /**\r\n     * Replace the patterns matching the given regular expression.\r\n     *\r\n     * @param { RegExp | RegExp[] } pattern\r\n     * @param { string | string[] | ((match: string[]) => string) } replace\r\n     * @param { number } limit\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    replaceMatches(pattern: RegExp | RegExp[], replace: string | string[] | ((match: string[]) => string), limit: number = -1): Stringable {\r\n        return new Stringable(Str.replaceMatches(pattern, replace, this.#value, limit));\r\n    }\r\n\r\n    /**\r\n     * Remove all \"extra\" blank space from the given string.\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    squish(): Stringable {\r\n        return new Stringable(Str.squish(this.#value));\r\n    }\r\n\r\n    /**\r\n     * Begin a string with a single instance of a given value.\r\n     *\r\n     * @param { string } prefix\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    start(prefix: string): Stringable {\r\n        return new Stringable(Str.start(this.#value, prefix));\r\n    }\r\n\r\n    /**\r\n     * Convert the given string to upper-case.\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    upper(): Stringable {\r\n        return new Stringable(Str.upper(this.#value));\r\n    }\r\n\r\n    /**\r\n     * Convert the given string to title case.\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    title(): Stringable {\r\n        return new Stringable(Str.title(this.#value));\r\n    }\r\n\r\n    /**\r\n     * Convert the given string to title case for each word.\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    headline(): Stringable {\r\n        return new Stringable(Str.headline(this.#value));\r\n    }\r\n\r\n    /**\r\n     * Convert the given string to APA-style title case.\r\n     *\r\n     * @see https://apastyle.apa.org/style-grammar-guidelines/capitalization/title-case\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    apa(): Stringable {\r\n        return new Stringable(Str.apa(this.#value));\r\n    }\r\n\r\n    /**\r\n     * Get the singular form of an English word.\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    singular(): Stringable {\r\n        return new Stringable(Str.singular(this.#value));\r\n    }\r\n\r\n    /**\r\n     * Generate a URL friendly \"slug\" from a given string.\r\n     *\r\n     * @param { string } separator\r\n     * @param { object } dictionary\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    slug(separator: string = '-', dictionary: Record<string, string> = { '@': 'at' }): Stringable {\r\n        return new Stringable(Str.slug(this.#value, separator, dictionary));\r\n    }\r\n\r\n    /**\r\n     * Convert a string to snake case.\r\n     *\r\n     * @param { string } delimiter\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    snake(delimiter: string = '_'): Stringable {\r\n        return new Stringable(Str.snake(this.#value, delimiter));\r\n    }\r\n\r\n    /**\r\n     * Determine if a given string starts with a given substring.\r\n     *\r\n     * @param { string | string[] } needles\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    startsWith(needles: string | string[]): boolean {\r\n        return Str.startsWith(this.#value, needles);\r\n    }\r\n\r\n    /**\r\n     * Determine if a given string doesn't start with a given substring.\r\n     *\r\n     * @param { string | string[] } needles\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    doesntStartWith(needles: string | string[]): boolean {\r\n        return Str.doesntStartWith(this.#value, needles);\r\n    }\r\n\r\n    /**\r\n     * Convert a value to studly caps case.\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    studly(): Stringable {\r\n        return new Stringable(Str.studly(this.#value));\r\n    }\r\n\r\n    /**\r\n     * Convert a value to Pascal case.\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    pascal(): Stringable {\r\n        return new Stringable(Str.pascal(this.#value));\r\n    }\r\n\r\n    /**\r\n     * Returns the portion of the string specified by the start and length parameters.\r\n     *\r\n     * @param { number } start\r\n     * @param { number | null } length\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    substr(start: number, length: number | null = null): Stringable {\r\n        return new Stringable(Str.substr(this.#value, start, length));\r\n    }\r\n\r\n    /**\r\n     * Returns the number of substring occurrences.\r\n     *\r\n     * @param { string } needle\r\n     * @param { number } offset\r\n     * @param { number | null } length\r\n     *\r\n     * @return { number }\r\n     */\r\n    substrCount(needle: string, offset: number = 0, length: number | null = null): number {\r\n        return Str.substrCount(this.#value, needle, offset, length);\r\n    }\r\n\r\n    /**\r\n     * Replace text within a portion of a string.\r\n     *\r\n     * @param { string } replace\r\n     * @param { number } offset\r\n     * @param { number | null } length\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    substrReplace(replace: string, offset: number = 0, length: number | null = null): Stringable {\r\n        return new Stringable(Str.substrReplace(this.#value, replace, offset, length));\r\n    }\r\n\r\n    /**\r\n     * Swap multiple keywords in a string with other keywords.\r\n     *\r\n     * @param { Record<string, string> } map\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    swap(map: Record<string, string>): Stringable {\r\n        return new Stringable(Str.swap(map, this.#value));\r\n    }\r\n\r\n    /**\r\n     * Take the first or last {limit} characters.\r\n     *\r\n     * @param { number } limit\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    take(limit: number): Stringable {\r\n        if (limit < 0) {\r\n            return this.substr(limit);\r\n        }\r\n\r\n        return this.substr(0, limit);\r\n    }\r\n\r\n    /**\r\n     * Call the given Closure with this instance then return the instance.\r\n     *\r\n     * @param { ((instance: this) => any) } callback\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    tap(callback: ((instance: this) => any)): this {\r\n        callback(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Trim the string of the given characters.\r\n     *\r\n     * @param { string | null } characters\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    trim(characters: string | null = null): Stringable {\r\n        return new Stringable(Str.trim(this.#value, characters));\r\n    }\r\n\r\n    /**\r\n     * Left trim the string of the given characters.\r\n     *\r\n     * @param { string | string[]|null } characters\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    ltrim(characters: string | null = null): Stringable {\r\n        return new Stringable(Str.ltrim(this.#value, characters));\r\n    }\r\n\r\n    /**\r\n     * Right trim the string of the given characters.\r\n     *\r\n     * @param { string | string[]|null } characters\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    rtrim(characters: string | null = null): Stringable {\r\n        return new Stringable(Str.rtrim(this.#value, characters));\r\n    }\r\n\r\n    /**\r\n     * Make a string's first character lowercase.\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    lcfirst(): Stringable {\r\n        return new Stringable(Str.lcfirst(this.#value));\r\n    }\r\n\r\n    /**\r\n     * Make a string's first character uppercase.\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    ucfirst(): Stringable {\r\n        return new Stringable(Str.ucfirst(this.#value));\r\n    }\r\n\r\n    /**\r\n     * Capitalize the first character of each word in a string.\r\n     *\r\n     * @param { string } separators\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    ucwords(separators: string = ' \\t\\r\\n\\f\\v'): Stringable {\r\n        return new Stringable(Str.ucwords(this.#value, separators));\r\n    }\r\n\r\n    /**\r\n     * Split a string by uppercase characters.\r\n     *\r\n     * @return { string[] }\r\n     */\r\n    ucsplit(): string[] {\r\n        return Str.ucsplit(this.#value);\r\n    }\r\n\r\n    /**\r\n     * Apply the callback if the given \"value\" is (or resolves to) truthy.\r\n     *\r\n     * @param { Value<this> } value\r\n     * @param { Callback<this> } callback\r\n     * @param { Fallback<this> } fallback\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    when(value: Value<this>, callback: Callback<this>, fallback: Fallback<this> = null): this {\r\n        value = typeof value === 'function' ? value(this) : value;\r\n\r\n        if (value) {\r\n            return callback(this, value) ?? this;\r\n        } else if (fallback) {\r\n            return fallback(this, value) ?? this;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Apply the callback if the given \"value\" is (or resolves to) falsy.\r\n     *\r\n     * @param { Value<this> } value\r\n     * @param { Callback<this> } callback\r\n     * @param { Fallback<this> } fallback\r\n     *\r\n     * @return { this }\r\n     */\r\n    unless(value: Value<this>, callback: Callback<this>, fallback: Fallback<this> = null): this {\r\n        value = typeof value === 'function' ? value(this) : value;\r\n\r\n        if (!value) {\r\n            return callback(this, value) ?? this;\r\n        } else if (fallback) {\r\n            return fallback(this, value) ?? this;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Execute the given callback if the string contains a given substring.\r\n     *\r\n     * @param { string | string[] } needles\r\n     * @param { Callback<this> } callback\r\n     * @param { Fallback<this> } fallback\r\n     *\r\n     * @return { this }\r\n     */\r\n    whenContains(needles: string | string[], callback: Callback<this>, fallback: Fallback<this> = null): this {\r\n        return this.when(this.contains(needles), callback, fallback);\r\n    }\r\n\r\n    /**\r\n     * Execute the given callback if the string contains all array values.\r\n     *\r\n     * @param { string[] } needles\r\n     * @param { Callback<this> } callback\r\n     * @param { Fallback<this> } fallback\r\n     *\r\n     * @return { this }\r\n     */\r\n    whenContainsAll(needles: string[], callback: Callback<this>, fallback: Fallback<this> = null): this {\r\n        return this.when(this.containsAll(needles), callback, fallback);\r\n    }\r\n\r\n    /**\r\n     * Execute the given callback if the string is empty.\r\n     *\r\n     * @param { Callback<this> } callback\r\n     * @param { Fallback<this> } fallback\r\n     *\r\n     * @return { this }\r\n     */\r\n    whenEmpty(callback: Callback<this>, fallback: Fallback<this> = null): this {\r\n        return this.when(this.isEmpty(), callback, fallback);\r\n    }\r\n\r\n    /**\r\n     * Execute the given callback if the string is not empty.\r\n     *\r\n     * @param { Callback<this> } callback\r\n     * @param { Fallback<this> } fallback\r\n     *\r\n     * @return { this }\r\n     */\r\n    whenNotEmpty(callback: Callback<this>, fallback: Fallback<this> = null): this {\r\n        return this.when(this.isNotEmpty(), callback, fallback);\r\n    }\r\n\r\n    /**\r\n     * Execute the given callback if the string ends with a given substring.\r\n     *\r\n     * @param { string | string[] } needles\r\n     * @param { Callback<this> } callback\r\n     * @param { Fallback<this> } fallback\r\n     *\r\n     * @return { this }\r\n     */\r\n    whenEndsWith(needles: string | string[], callback: Callback<this>, fallback: Fallback<this> = null): this {\r\n        return this.when(this.endsWith(needles), callback, fallback);\r\n    }\r\n\r\n    /**\r\n     * Execute the given callback if the string doesn't end with a given substring.\r\n     *\r\n     * @param { string | string[] } needles\r\n     * @param { Callback<this> } callback\r\n     * @param { Fallback<this> } fallback\r\n     *\r\n     * @return { this }\r\n     */\r\n    whenDoesntEndWith(needles: string | string[], callback: Callback<this>, fallback: Fallback<this> = null): this {\r\n        return this.when(this.doesntEndWith(needles), callback, fallback);\r\n    }\r\n\r\n    /**\r\n     * Execute the given callback if the string is an exact match with the given value.\r\n     *\r\n     * @param { string } value\r\n     * @param { Callback<this> } callback\r\n     * @param { Fallback<this> } fallback\r\n     *\r\n     * @return { this }\r\n     */\r\n    whenExactly(value: string, callback: Callback<this>, fallback: Fallback<this> = null): this {\r\n        return this.when(this.exactly(value), callback, fallback);\r\n    }\r\n\r\n    /**\r\n     * Execute the given callback if the string is not an exact match with the given value.\r\n     *\r\n     * @param { string } value\r\n     * @param { Callback<this> } callback\r\n     * @param { Fallback<this> } fallback\r\n     *\r\n     * @return { this }\r\n     */\r\n    whenNotExactly(value: string, callback: Callback<this>, fallback: Fallback<this> = null): this {\r\n        return this.when(!this.exactly(value), callback, fallback);\r\n    }\r\n\r\n    /**\r\n     * Execute the given callback if the string matches a given pattern.\r\n     *\r\n     * @param { string | string[] } pattern\r\n     * @param { Callback<this> } callback\r\n     * @param { Fallback<this> } fallback\r\n     *\r\n     * @return { this }\r\n     */\r\n    whenIs(pattern: string | string[], callback: Callback<this>, fallback: Fallback<this> = null): this {\r\n        return this.when(this.is(pattern), callback, fallback);\r\n    }\r\n\r\n    /**\r\n     * Execute the given callback if the string is 7-bit ASCII.\r\n     *\r\n     * @param { Callback<this> } callback\r\n     * @param { Fallback<this> } fallback\r\n     *\r\n     * @return { this }\r\n     */\r\n    whenIsAscii(callback: Callback<this>, fallback: Fallback<this> = null): this {\r\n        return this.when(this.isAscii(), callback, fallback);\r\n    }\r\n\r\n    /**\r\n     * Execute the given callback if the string is a valid UUID.\r\n     *\r\n     * @param { Callback<this> } callback\r\n     * @param { Fallback<this> } fallback\r\n     *\r\n     * @return { this }\r\n     */\r\n    whenIsUuid(callback: Callback<this>, fallback: Fallback<this> = null): this {\r\n        return this.when(this.isUuid(), callback, fallback);\r\n    }\r\n\r\n    /**\r\n     * Execute the given callback if the string is a valid ULID.\r\n     *\r\n     * @param { Callback<this> } callback\r\n     * @param { Fallback<this> } fallback\r\n     *\r\n     * @return { this }\r\n     */\r\n    whenIsUlid(callback: Callback<this>, fallback: Fallback<this> = null): this {\r\n        return this.when(this.isUlid(), callback, fallback);\r\n    }\r\n\r\n    /**\r\n     * Execute the given callback if the string starts with a given substring.\r\n     *\r\n     * @param { string | string[] } needles\r\n     * @param { Callback<this> } callback\r\n     * @param { Fallback<this> } fallback\r\n     *\r\n     * @return { this }\r\n     */\r\n    whenStartsWith(needles: string | string[], callback: Callback<this>, fallback: Fallback<this> = null): this {\r\n        return this.when(this.startsWith(needles), callback, fallback);\r\n    }\r\n\r\n    /**\r\n     * Execute the given callback if the string doesn't start with a given substring.\r\n     *\r\n     * @param { string | string[] } needles\r\n     * @param { Callback<this> } callback\r\n     * @param { Fallback<this> } fallback\r\n     *\r\n     * @return { this }\r\n     */\r\n    whenDoesntStartWith(needles: string | string[], callback: Callback<this>, fallback: Fallback<this> = null): this {\r\n        return this.when(this.doesntStartWith(needles), callback, fallback);\r\n    }\r\n\r\n    /**\r\n     * Execute the given callback if the string matches the given pattern.\r\n     *\r\n     * @param { RegExp } pattern\r\n     * @param { Callback<this> } callback\r\n     * @param { Fallback<this> } fallback\r\n     *\r\n     * @return { this }\r\n     */\r\n    whenTest(pattern: RegExp, callback: Callback<this>, fallback: Fallback<this> = null): this {\r\n        return this.when(this.test(pattern), callback, fallback);\r\n    }\r\n\r\n    /**\r\n     * Limit the number of words in a string.\r\n     *\r\n     * @param { number } words\r\n     * @param { string } end\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    words(words: number = 100, end: string = '...'): Stringable {\r\n        return new Stringable(Str.words(this.#value, words, end));\r\n    }\r\n\r\n    /**\r\n     * Get the number of words a string contains.\r\n     *\r\n     * @return { number }\r\n     */\r\n    wordCount(): number {\r\n        return Str.wordCount(this.#value);\r\n    }\r\n\r\n    /**\r\n     * Wrap a string to a given number of characters.\r\n     *\r\n     * @param { number } characters\r\n     * @param { string } breakStr\r\n     * @param { boolean } cutLongWords\r\n     *\r\n     * @returns { this }\r\n     */\r\n    wordWrap(characters: number = 75, breakStr: string = '\\n', cutLongWords: boolean = false): Stringable {\r\n        return new Stringable(Str.wordWrap(this.#value, characters, breakStr, cutLongWords));\r\n    }\r\n\r\n    /**\r\n     * Wrap the string with the given strings.\r\n     *\r\n     * @param { string } before\r\n     * @param { string | null } after\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    wrap(before: string, after: string | null = null): Stringable {\r\n        return new Stringable(Str.wrap(this.#value, before, after));\r\n    }\r\n\r\n    /**\r\n     * Unwrap the string with the given strings.\r\n     *\r\n     * @param { string } before\r\n     * @param { string | null } after\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    unwrap(before: string, after: string | null = null): Stringable {\r\n        return new Stringable(Str.unwrap(this.#value, before, after));\r\n    }\r\n\r\n    /**\r\n     * Convert the string into a `HtmlString` instance.\r\n     *\r\n     * @return { HtmlStringType }\r\n     */\r\n    toHtmlString(): HtmlStringType {\r\n        return new HtmlString(this.#value).toHtml();\r\n    }\r\n\r\n    /**\r\n     * Convert the string to Base64 encoding.\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    toBase64(): Stringable {\r\n        return new Stringable(Str.toBase64(this.#value));\r\n    }\r\n\r\n    /**\r\n     * Decode the Base64 encoded string.\r\n     *\r\n     * @return { Stringable }\r\n     */\r\n    fromBase64(): Stringable {\r\n        return new Stringable(Str.fromBase64(this.#value));\r\n    }\r\n\r\n    /**\r\n     * Dump the string.\r\n     *\r\n     * @return { void }\r\n     */\r\n    dump(): void {\r\n        console.log(this.#value);\r\n    }\r\n\r\n    /**\r\n     * Dump the string and end the script.\r\n     *\r\n     * @return { never }\r\n     */\r\n    dd(): never {\r\n        this.dump();\r\n\r\n        throw new Error('dd()');\r\n    }\r\n\r\n    /**\r\n     * Get the underlying string value.\r\n     *\r\n     * @return { string }\r\n     */\r\n    value(): string {\r\n        return this.toString();\r\n    }\r\n\r\n    /**\r\n     * Get the raw string value.\r\n     *\r\n     * @return { string }\r\n     */\r\n    toString(): string {\r\n        return this.#value;\r\n    }\r\n\r\n    /**\r\n     * Get the underlying string value as an integer.\r\n     *\r\n     * @param { number } base\r\n     *\r\n     * @return { number }\r\n     */\r\n    toInteger(base: number = 10): number {\r\n        const value: number = Number.parseInt(this.#value, base);\r\n\r\n        return Number.isNaN(value) || !Number.isFinite(value) ? 0 : value;\r\n    }\r\n\r\n    /**\r\n     * Get the underlying string value as a float.\r\n     *\r\n     * @return { number }\r\n     */\r\n    toFloat(): number {\r\n        const value: number = Number.parseFloat(this.#value);\r\n\r\n        return Number.isNaN(value) ? 0 : value;\r\n    }\r\n\r\n    /**\r\n     * Get the underlying string value as a boolean.\r\n     *\r\n     * Returns true when value is \"1\", \"true\", \"on\", and \"yes\". Otherwise, returns false.\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    toBoolean(): boolean {\r\n        switch (this.#value) {\r\n            case '1':\r\n            case 'true':\r\n            case 'on':\r\n            case 'yes':\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the underlying string value as a formatted Date string.\r\n     *\r\n     * @param { string | null } format\r\n     * @param { string | null } tz\r\n     */\r\n    toDate(format: string | null = null, tz: string | null = null): string {\r\n        if (new Date(this.#value).toString() === 'Invalid Date') {\r\n            return 'Invalid Date';\r\n        }\r\n\r\n        if (format === null) {\r\n            return new Date(this.#value).toLocaleDateString('en-us', {\r\n                year    : 'numeric',\r\n                month   : 'numeric',\r\n                day     : 'numeric',\r\n                hour    : 'numeric',\r\n                minute  : 'numeric',\r\n                second  : 'numeric',\r\n                hour12  : false,\r\n                timeZone: tz ?? undefined,\r\n            });\r\n        }\r\n\r\n        let date: string = '';\r\n\r\n        const now: Date = new Date(new Date(this.#value).toLocaleString('en-US', {\r\n            year                  : 'numeric',\r\n            month                 : 'numeric',\r\n            day                   : 'numeric',\r\n            hour                  : 'numeric',\r\n            minute                : 'numeric',\r\n            second                : 'numeric',\r\n            fractionalSecondDigits: 3,\r\n            hour12                : false,\r\n            timeZone              : tz ?? undefined,\r\n        }));\r\n\r\n        const month: number = now.getMonth();\r\n        const dayOfTheWeek: number = now.getDay();\r\n        const dayOfTheMonth: number = now.getDate();\r\n        const year: number = now.getFullYear();\r\n        const hours: number = now.getHours();\r\n        const minutes: number = now.getMinutes();\r\n        const seconds: number = now.getSeconds();\r\n        const milliseconds: number = now.getMilliseconds();\r\n\r\n        const elements: RegExpMatchArray | null = format.match(/\\\\?.|./g);\r\n\r\n        for (const element of elements!) {\r\n            switch (element) {\r\n                // Day of the month, 2 digits with leading zeros (e.g., 01 to 31)\r\n                case 'd':\r\n                    date += Str.padLeft(dayOfTheMonth.toString(), 2, '0');\r\n\r\n                    break;\r\n\r\n                // A textual representation of a day, three letters (e.g., Mon through Sun)\r\n                case 'D':\r\n                    date += now.toLocaleString('en-US', { weekday: 'short' });\r\n\r\n                    break;\r\n\r\n                // Day of the month without leading zeros (e.g., 1 to 31)\r\n                case 'j':\r\n                    date += dayOfTheMonth;\r\n\r\n                    break;\r\n\r\n                // A full textual representation of the day of the week (e.g., Sunday through Saturday)\r\n                case 'l':\r\n                    date += now.toLocaleString('en-US', { weekday: 'long' });\r\n\r\n                    break;\r\n\r\n                // ISO 8601 numeric representation of the day of the week (e.g., 1 (for Monday) through 7 (for Sunday))\r\n                case 'N':\r\n                    date += dayOfTheWeek;\r\n\r\n                    break;\r\n\r\n                // English ordinal suffix for the day of the month, 2 characters (e.g., st, nd, rd or th)\r\n                case 'S': {\r\n                    let suffix: Record<number, string> = { 1: 'st', 2: 'nd', 3: 'rd', 21: 'st', 22: 'nd', 23: 'rd', 31: 'st' };\r\n                    date += suffix[dayOfTheMonth] ?? 'th';\r\n\r\n                    break;\r\n                }\r\n\r\n                // Numeric representation of the day of the week (e.g., 0 (for Sunday) through 6 (for Saturday))\r\n                case 'w':\r\n                    date += dayOfTheWeek;\r\n\r\n                    break;\r\n\r\n                // Numeric representation of the day of the week (e.g., The day of the year (starting from 0))\r\n                case 'z': {\r\n                    let start: Date = new Date(year, 0, 0);\r\n                    let diff: number = ((now as unknown as number) - (start as unknown as number)) + ((start.getTimezoneOffset() - now.getTimezoneOffset()) * 60 * 1000);\r\n                    let day: number = 86400000;\r\n                    const currentDay: number = Math.floor(diff / day);\r\n\r\n                    date += currentDay;\r\n\r\n                    break;\r\n                }\r\n\r\n                // ISO 8601 week number of year, weeks starting on Monday (e.g., 42 (the 42nd week in the year))\r\n                case 'W': {\r\n                    let parsedDate: Date = new Date(Date.UTC(year, month, dayOfTheMonth));\r\n                    let weekDay: number = parsedDate.getUTCDay() || 7;\r\n\r\n                    parsedDate.setUTCDate(parsedDate.getUTCDate() + 4 - weekDay);\r\n\r\n                    let yearStart: Date = new Date(Date.UTC(parsedDate.getUTCFullYear(), 0, 1));\r\n                    let weekNumber: number = Math.ceil(((((parsedDate as unknown as number) - (yearStart as unknown as number)) / 86400000) + 1) / 7);\r\n\r\n                    date += Str.padLeft((weekNumber.toString()), 2, '0');\r\n\r\n                    break;\r\n                }\r\n\r\n                // A full textual representation of a month, such as January or March (e.g., January through December)\r\n                case 'F':\r\n                    date += now.toLocaleString('en-US', { month: 'long' });\r\n\r\n                    break;\r\n\r\n                // Numeric representation of a month, with leading zeros (e.g., 01 through 12)\r\n                case 'm': {\r\n                    const currentMonth: number = month + 1;\r\n\r\n                    date += Str.padLeft(currentMonth.toString(), 2, '0');\r\n\r\n                    break;\r\n                }\r\n\r\n                // A short textual representation of a month, three letters (e.g., Jan through Dec)\r\n                case 'M':\r\n                    date += now.toLocaleString('en-US', { month: 'short' });\r\n\r\n                    break;\r\n\r\n                // Numeric representation of a month, without leading zeros (e.g., 1 through 12)\r\n                case 'n':\r\n                    date += month + 1;\r\n\r\n                    break;\r\n\r\n                // Number of days in the given month (e.g., 28 through 31)\r\n                case 't':\r\n                    date += new Date(year, month + 1, 0).getDate();\r\n\r\n                    break;\r\n\r\n                // Whether it's a leap year (e.g., 1 if it is a leap year, 0 otherwise)\r\n                case 'L':\r\n                    date += new Date(year, 1, 29).getMonth() === 1 ? '1' : '0';\r\n\r\n                    break;\r\n\r\n                // ISO 8601 week-numbering year. This has the same value as Y,\r\n                // except that if the ISO week number (W) belongs to the previous or next year,\r\n                // that year is used instead. (e.g., 1999 or 2003)\r\n                case 'o':\r\n                    date += now.toISOString().substring(0, 4);\r\n\r\n                    break;\r\n\r\n                // An expanded full numeric representation of a year, at least 4 digits, with - for years BCE, and + for years CE. (e.g., -0055, +0787, +1999, +10191)\r\n                case 'X':\r\n                    date += year < 0 ? '-' + year : '+' + year;\r\n\r\n                    break;\r\n\r\n                // An expanded full numeric representation if required,\r\n                // or a standard full numeral representation if possible (like Y).\r\n                // At least four digits. Years BCE are prefixed with a -.\r\n                // Years beyond (and including) 10000 are prefixed by a +. (e.g., -0055, 0787, 1999, +10191)\r\n                case 'x':\r\n                    date += year < 10000 ? year : '-' + year;\r\n\r\n                    break;\r\n\r\n                // A full numeric representation of a year, at least 4 digits, with - for years BCE. (e.g., -0055, 0787, 1999, 2003, 10191)\r\n                case 'Y':\r\n                    date += year;\r\n\r\n                    break;\r\n\r\n                // A two-digit representation of a year (e.g., 99 or 03)\r\n                case 'y':\r\n                    date += year.toString().substring(2);\r\n\r\n                    break;\r\n\r\n                // Lowercase Ante meridiem and Post meridiem (e.g., am or pm)\r\n                case 'a':\r\n                    date += hours < 12 ? 'am' : 'pm';\r\n\r\n                    break;\r\n\r\n                // Uppercase Ante meridiem and Post meridiem (e.g., AM or PM)\r\n                case 'A':\r\n                    date += hours < 12 ? 'AM' : 'PM';\r\n\r\n                    break;\r\n\r\n                // Swatch Internet time (e.g., 000 through 999)\r\n                case 'B': {\r\n                    const hours: number = now.getUTCHours();\r\n                    const minutes: number = now.getUTCMinutes();\r\n                    const seconds: number = now.getUTCSeconds();\r\n\r\n                    date += Math.floor((((hours + 1) % 24) + minutes / 60 + seconds / 3600) * 1000 / 24);\r\n\r\n                    break;\r\n                }\r\n\r\n                // 12-hour format of an hour without leading zeros (e.g., 1 through 12)\r\n                case 'g':\r\n                    date += hours > 12 ? hours - 12 : hours;\r\n\r\n                    break;\r\n\r\n                // 24-hour format of an hour without leading zeros (e.g., 0 through 23)\r\n                case 'G':\r\n                    date += hours;\r\n\r\n                    break;\r\n\r\n                // 12-hour format of an hour with leading zeros (e.g., 01 through 12)\r\n                case 'h':\r\n                    date += Str.padLeft((hours > 12 ? hours - 12 : hours).toString(), 2, '0');\r\n\r\n                    break;\r\n\r\n                // 24-hour format of an hour with leading zeros (e.g., 00 through 23)\r\n                case 'H':\r\n                    date += Str.padLeft(hours.toString(), 2, '0');\r\n\r\n                    break;\r\n\r\n                // Minutes with leading zeros (e.g., 00 to 59)\r\n                case 'i':\r\n                    date += Str.padLeft(minutes.toString(), 2, '0');\r\n\r\n                    break;\r\n\r\n                // Seconds with leading zeros (e.g., 00 to 59)\r\n                case 's':\r\n                    date += Str.padLeft(seconds.toString(), 2, '0');\r\n\r\n                    break;\r\n\r\n                // Microseconds. (e.g., 654321)\r\n                case 'u':\r\n                    throw new Error('Microseconds are not supported.');\r\n\r\n                // Milliseconds. (e.g., 654)\r\n                case 'v': {\r\n                    date += Str.padLeft(milliseconds.toString(), 3, '0');\r\n\r\n                    break;\r\n                }\r\n\r\n                // Timezone identifier (e.g., UTC, GMT, Atlantic/Azores)\r\n                case 'e': {\r\n                    date += Intl.DateTimeFormat('en-us', { timeZone: tz ?? undefined }).resolvedOptions().timeZone;\r\n\r\n                    break;\r\n                }\r\n\r\n                // Whether the date is in daylight saving time (e.g., 1 if Daylight Saving Time, 0 otherwise)\r\n                case 'I': {\r\n                    let january: number = new Date(year, 0, 1).getTimezoneOffset();\r\n                    let july: number = new Date(year, 6, 1).getTimezoneOffset();\r\n\r\n                    date += Math.max(january, july) === now.getTimezoneOffset() ? '0' : '1';\r\n\r\n                    break;\r\n                }\r\n\r\n                // Difference to Greenwich time (GMT) without colon between hours and minutes (e.g., +0200)\r\n                case 'O': {\r\n                    const timeZoneData: string = now.toLocaleDateString('en-us', { timeZoneName: 'longOffset', timeZone: tz ?? undefined, })\r\n                        .split(', ')\r\n                        .pop()!\r\n                        .trim();\r\n\r\n                    date += timeZoneData.length === 3 ? '+0000' : timeZoneData.substring(3).replace(':', '');\r\n\r\n                    break;\r\n                }\r\n\r\n                // Difference to Greenwich time (GMT) with colon between hours and minutes (e.g., +02:00)\r\n                case 'P': {\r\n                    const timeZoneData: string = now.toLocaleDateString('en-us', { timeZoneName: 'longOffset', timeZone: tz ?? undefined })\r\n                        .split(', ')\r\n                        .pop()!\r\n                        .trim();\r\n\r\n                    date += timeZoneData.length === 3 ? '+00:00' : timeZoneData.substring(3);\r\n\r\n                    break;\r\n                }\r\n\r\n                // The same as P, but returns Z instead of +00:00 (e.g., +02:00)\r\n                case 'p': {\r\n                    const timeZoneData: string = now.toLocaleDateString('en-us', { timeZoneName: 'longOffset', timeZone: tz ?? undefined, })\r\n                        .split(', ')\r\n                        .pop()!\r\n                        .trim();\r\n\r\n                    date += timeZoneData === 'GMT' ? 'Z' : timeZoneData.substring(3);\r\n\r\n                    break;\r\n                }\r\n\r\n                // Timezone abbreviation, if known; otherwise the GMT offset (e.g., EST, MDT, +05)\r\n                case 'T': {\r\n                    const timeZoneData: string = now.toLocaleDateString('en-us', { timeZoneName: 'short', timeZone: tz ?? undefined, })\r\n                        .split(', ')\r\n                        .pop()!\r\n                        .trim();\r\n\r\n                    date += tz ?? timeZoneData.replace('GMT', 'UTC').split(/[+-]/)[0];\r\n\r\n                    break;\r\n                }\r\n\r\n                // Timezone offset in seconds.\r\n                // The offset for timezones west of UTC is always negative,\r\n                // and for those east of UTC is always positive. (e.g., -43200 through 50400)\r\n                case 'Z': {\r\n                    const timezone: string = now.toLocaleDateString('en-us', { timeZoneName: 'longOffset', timeZone: tz ?? undefined });\r\n                    const symbol: RegExpMatchArray | null = timezone.match(/[+-]/);\r\n                    const data: string[] = timezone.split(/[+-]/);\r\n\r\n                    const sign: string = symbol ? symbol.pop()! : '+';\r\n                    const offset: string = data.length === 2 ? (data[1] as string) : '0:00';\r\n\r\n                    const hours: number = Number.parseInt(offset.split(':')[0] as string);\r\n                    const minutes: number = Number.parseInt(offset.split(':')[1] as string);\r\n\r\n                    const offsetInSeconds: number = hours * 3600 + minutes * 60;\r\n\r\n                    date += `${sign}${offsetInSeconds}`;\r\n\r\n                    break;\r\n                }\r\n\r\n                // ISO 8601 date (e.g., 2004-02-12T15:19:21+00:00)\r\n                case 'c': {\r\n                    date += `${this.toDate('Y-m-d\\\\TH:i:sP')}`;\r\n\r\n                    break;\r\n                }\r\n\r\n                // RFC 2822/RFC 5322 formatted date (e.g., Thu, 21 Dec 2000 16:01:07 +0200)\r\n                case 'r': {\r\n                    date += new Stringable(this.#value).toDate('D, d M Y H:i:s O', tz);\r\n\r\n                    break;\r\n                }\r\n\r\n                // Seconds since the Unix Epoch (e.g., January 1, 1970 00:00:00 GMT)\r\n                case 'U': {\r\n                    date += Math.floor(now.getTime() / 1000);\r\n\r\n                    break;\r\n                }\r\n\r\n                default:\r\n                    date += element.length >= 2 && element.includes('\\\\') ? element.replace('\\\\', '') : element;\r\n            }\r\n        }\r\n\r\n        return date;\r\n    }\r\n}\r\n\r\nexport class HtmlString {\r\n    /**\r\n     * The HTML string.\r\n     *\r\n     * @type { string }\r\n     */\r\n    readonly #html: string;\r\n\r\n    /**\r\n     * Create a new HTML string instance.\r\n     *\r\n     * @param { string } html\r\n     *\r\n     * @return void\r\n     */\r\n    constructor(html: string = '') {\r\n        this.#html = html;\r\n    }\r\n\r\n    /**\r\n     * Get the HTML string.\r\n     *\r\n     * @return { HtmlStringType }\r\n     */\r\n    toHtml(): HtmlStringType {\r\n        const pattern: RegExp = /(?!<!DOCTYPE)<([^\\s>]+)(\\s|>)+/;\r\n        const tag: RegExpExecArray | null = new RegExp(pattern).exec(this.#html);\r\n\r\n        if (tag === null) {\r\n            return this.#html;\r\n        }\r\n\r\n        const DOM: HTMLElement = document.createElement(tag[1] as string);\r\n\r\n        DOM.innerHTML = this.#html;\r\n\r\n        return tag[1] === 'html' ? DOM : DOM.firstChild as HtmlStringType;\r\n    }\r\n\r\n    /**\r\n     * Determine if the given HTML string is empty.\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    isEmpty(): boolean {\r\n        return this.#html === '';\r\n    }\r\n\r\n    /**\r\n     * Determine if the given HTML string is not empty.\r\n     *\r\n     * @return { boolean }\r\n     */\r\n    isNotEmpty(): boolean {\r\n        return !this.isEmpty();\r\n    }\r\n\r\n    /**\r\n     * Get the HTML string.\r\n     *\r\n     * @return { string }\r\n     */\r\n    toString(): string {\r\n        const html: HtmlStringType = this.toHtml();\r\n\r\n        if (html instanceof HTMLElement) {\r\n            return html.outerHTML;\r\n        }\r\n\r\n        if (html instanceof Node) {\r\n            return html.textContent as string;\r\n        }\r\n\r\n        return html;\r\n    }\r\n}\r\n\r\n/**\r\n * Get a new Stringable object from the given string.\r\n *\r\n * @param { string } string\r\n *\r\n * @return Stringable\r\n */\r\nexport function str(string: string = ''): Stringable {\r\n    return Str.of(string);\r\n}\r\n\r\n/**\r\n * Quote regular expression characters.\r\n *\r\n * @param { string } string The input string.\r\n * @param { string | null } delimiter If the optional delimiter is specified, it will also be escaped.\r\n * This is useful for escaping the delimiter that is required by the PCRE functions.\r\n * The / is the most commonly used delimiter.\r\n *\r\n * @return { string } The quoted (escaped) string.\r\n */\r\nfunction preg_quote(string: string, delimiter: string | null = null): string {\r\n    const characters: (string | null)[] = [\r\n        '-', '.', '\\\\', '+', '*', '?', '[', '^', ']',\r\n        '$', '(', ')', '{', '}', '=', '!', '<', '>',\r\n        '|', ':', delimiter\r\n    ];\r\n\r\n    const escaped: string = characters.filter(Boolean).map((character: string): string => `\\\\${character}`).join('');\r\n\r\n    return string.replace(new RegExp(`[${escaped}]`, 'g'), '\\\\$&');\r\n}\r\n\r\n/**\r\n * Uppercase the first character of each word in a string\r\n *\r\n * @param { string } string The input string.\r\n * @param { string } separators The optional separators contains the word separator characters.\r\n\r\n * @return { string } String the modified string.\r\n */\r\nfunction ucwords(string: string, separators: string = ' \\t\\r\\n\\f\\v'): string {\r\n    return string.split(separators).map((word: string): string => word[0]?.toUpperCase() + word.substring(1)).join(' ');\r\n}\r\n\r\n/**\r\n * Attempt to match the case on two strings.\r\n *\r\n * @param { string} value\r\n * @param { string } comparison\r\n *\r\n * @return { string }\r\n */\r\nfunction matchCase(value: string, comparison: string): string {\r\n    const cases: ((value: string) => string)[] = [\r\n        (value: string): string => value.toLowerCase(),\r\n        (value: string): string => value.toUpperCase(),\r\n        (value: string): string => value.charAt(0).toUpperCase() + value.slice(1),\r\n        (value: string): string => value.replace(/\\b\\w/g, (char: string): string => char.toUpperCase())\r\n    ];\r\n\r\n    for (const matcher of cases) {\r\n        if (matcher(comparison) === comparison) {\r\n            return matcher(value);\r\n        }\r\n    }\r\n\r\n    return value;\r\n}\r\n\r\nif (exports !== undefined) {\r\n    module.exports.Mode = Mode;\r\n    module.exports.Str = Str;\r\n    module.exports.Stringable = Stringable;\r\n    module.exports.HtmlString = HtmlString;\r\n    module.exports.str = str;\r\n}\r\n\r\nif (globalThis.global !== undefined) {\r\n    const _global: any = globalThis.global;\r\n\r\n    _global.Mode = Mode;\r\n    _global.Str = Str;\r\n    _global.Stringable = Stringable;\r\n    _global.HtmlString = HtmlString;\r\n    _global.str = str;\r\n}\r\n"],"names":["Mode","Str","of","string","Stringable","after","subject","search","slice","indexOf","length","afterLast","position","lastIndexOf","substring","ascii","value","normalize","replace","before","result","beforeLast","this","substr","between","from","to","betweenFirst","camel","lcfirst","studly","charAt","index","chopStart","needle","results","Array","isArray","word","startsWith","chopEnd","endsWith","contains","haystack","needles","ignoreCase","toLowerCase","includes","containsAll","doesntContain","convertCase","mode","MB_CASE_FOLD","MB_CASE_UPPER","toLocaleUpperCase","MB_CASE_LOWER","toLocaleLowerCase","MB_CASE_TITLE","title","MB_CASE_UPPER_SIMPLE","toUpperCase","MB_CASE_LOWER_SIMPLE","MB_CASE_TITLE_SIMPLE","MB_CASE_FOLD_SIMPLE","Error","deduplicate","characters","reduce","carry","character","RegExp","preg_quote","some","doesntEndWith","excerpt","text","phrase","options","radius","_a","omission","_b","matches","match","start","trimStart","end","trimEnd","Math","max","ltrim","unless","startWithRadius","exactly","prepend","toString","rtrim","endWithRadius","append","finish","cap","wrap","unwrap","replaceFirst","replaceLast","is","pattern","patterns","test","isAscii","isJson","JSON","parse","isUrl","protocols","protocol","join","isUuid","isUlid","Number","parseInt","kebab","snake","limit","preserveWords","trim","trimmed","lower","words","wordsArray","splice","mask","endIndex","segment","strLen","startIndex","segmentLen","repeat","exec","isMatch","item","matchAll","flags","Set","expression","map","String","numbers","padBoth","pad","short","shortLeft","floor","shortRight","ceil","padLeft","padRight","plural","count","undefined","ouse$","o$","eau$","us$","$","irregular","abuse","alumna","alumnus","analysis","appendix","atlas","avalanche","axis","axe","bacillus","bacterium","basis","beau","beef","blouse","brother","brownie","bureau","cache","cactus","cafe","calf","canvas","cave","chateau","child","cookie","corpus","cow","crisis","criterion","curriculum","curve","datum","deer","demo","diagnosis","domino","echo","elf","ellipsis","emphasis","epoch","fish","focus","foe","foot","formula","fungus","ganglion","gas","genie","genus","goose","graffito","grave","half","hippopotamus","hoax","hoof","human","iris","knife","larva","leaf","lens","life","loaf","man","matrix","means","medium","memorandum","money","mongoose","mouse","motto","move","mythos","nebula","neurosis","niche","niveau","nucleus","numen","oasis","occiput","octopus","offspring","opus","ox","parenthesis","passerby","penis","person","phenomenon","plateau","safe","save","scarf","self","series","sex","sheep","shelf","sieve","soliloquy","species","stadium","stimulus","stratum","swine","syllabus","synthesis","testis","thesis","thief","tooth","tornado","trilby","turf","valve","volcano","wave","wife","wolf","zombie","has","matchCase","pluralStudly","parts","split","lastWord","pop","ucfirst","pluralPascal","password","letters","symbols","spaces","collection","option","push","random","Object","values","flat","i","toSorted","previous","current","offset","randomStringFactory","byteSize","bytes","crypto","getRandomValues","Uint8Array","btoa","createRandomStringsUsing","factory","createRandomStringsUsingSequence","sequence","whenMissing","next","factoryCache","randomString","createRandomStringsNormally","times","replaceArray","segments","shift","toStringOr","caseSensitive","term","$subject","$replace","replacement","replaceAll","replaceStart","replaceEnd","replaceMatches","args","remove","reverse","prefix","quoted","upper","headline","part","ucsplit","filter","Boolean","apa","minorWords","endPunctuation","lowercaseWord","hyphenatedWords","singular","ouses$","eaus$","s$","abuses","alumnae","alumni","analyses","appendices","atlases","avalanches","axes","bacilli","bacteria","bases","beaux","beefs","blouses","brothers","brownies","bureaux","caches","cacti","cafes","calves","canvases","caves","chateaux","children","cookies","corpuses","cows","crises","criteria","curricula","curves","demos","diagnoses","dominoes","echoes","elves","ellipses","emphases","epochs","foci","foes","feet","formulae","fungi","ganglions","gases","genies","genera","geese","graffiti","graves","halves","hippopotami","hoaxes","hoofs","humans","irises","knives","larvae","leaves","lenses","lives","loaves","men","matrices","media","memoranda","monies","mongooses","mice","mottoes","moves","mythoi","nebulae","neuroses","niches","niveaux","nuclei","numina","oases","occiputs","octopuses","opuses","oxen","parentheses","passersby","penises","people","phenomena","plateaux","radii","safes","saves","scarves","selves","sexes","shelves","sieves","soliloquies","stadiums","stimuli","strata","syllabi","syntheses","testes","theses","thieves","teeth","tornadoes","trilbys","turfs","valves","volcanoes","waves","wives","wolves","zombies","slug","separator","dictionary","flip","delimiter","separators","ucwords","regex","squish","doesntStartWith","pascal","substrCount","substrReplace","swap","take","toBase64","fromBase64","atob","wordCount","wordWrap","breakStr","cutLongWords","breakWithSpace","uuid","uuidFactory","time","MAX_SAFE_INTEGER","randomChar","trunc","uuid7","Uint32Array","timestamp","getTime","Date","now","RangeError","r1","r2","r3","randomA","randomBHi","randomBLo","pow","digits","orderedUuid","createUuidsUsing","createUuidsUsingSequence","freezeUuids","callback","createUuidsNormally","ulid","ulidFactory","encoding","generateRandomNumber","buffer","encodedTime","mod","generateEncodedTime","randomNumber","encodingLength","generateRandomString","createUlidsUsing","createUlidsUsingSequence","freezeUlids","createUlidsNormally","fallback","defineProperty","constructor","_Stringable_value","set","__classPrivateFieldSet","__classPrivateFieldGet","newLine","basename","suffix","classBasename","dirname","levels","explode","isEmpty","isNotEmpty","pipe","tap","when","whenContains","whenContainsAll","whenEmpty","whenNotEmpty","whenEndsWith","whenDoesntEndWith","whenExactly","whenNotExactly","whenIs","whenIsAscii","whenIsUuid","whenIsUlid","whenStartsWith","whenDoesntStartWith","whenTest","toHtmlString","HtmlString","toHtml","dump","console","log","dd","toInteger","base","isNaN","isFinite","toFloat","parseFloat","toBoolean","toDate","format","tz","toLocaleDateString","year","month","day","hour","minute","second","hour12","timeZone","date","toLocaleString","fractionalSecondDigits","getMonth","dayOfTheWeek","getDay","dayOfTheMonth","getDate","getFullYear","hours","getHours","minutes","getMinutes","seconds","getSeconds","milliseconds","getMilliseconds","elements","element","weekday","diff","getTimezoneOffset","parsedDate","UTC","weekDay","getUTCDay","setUTCDate","getUTCDate","yearStart","getUTCFullYear","weekNumber","currentMonth","toISOString","getUTCHours","getUTCMinutes","getUTCSeconds","Intl","DateTimeFormat","resolvedOptions","january","july","timeZoneData","timeZoneName","timezone","symbol","data","sign","html","_HtmlString_html","tag","DOM","document","createElement","innerHTML","firstChild","HTMLElement","outerHTML","Node","textContent","str","escaped","comparison","cases","char","matcher","exports","module","globalThis","global","_global"],"mappings":"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WACA,OACA,MACA,SACA,eACA,WACA,cACA,YACA,QACA,SAGA,OACA,SACA,OACA,WACA,QAGA,YACA,QACA,MACA,QACA,YACA,WAGA,UACA,WACA,OACA,WACA,QACA,aACA,OACA,YAGA,UACA,WACA,UACA,aACA,OAGA,eACA,SACA,UACA,WACA,aACA,eAGA,aACA,cACA,UAGA,aACA,QACA,OAGA,MACA,aACA,YACA,WAGA,UACA,OACA,WACA,UAGA,WACA,UACA,aACA,WACA,OACA,QACA,QACA,QACA,QAGA,aACA,OACA,QACA,UACA,YAGA,MACA,YAGA,WACA,YACA,cACA,OACA,UACA,YACA,WACA,SACA,UACA,SACA,SACA,aACA,cACA,WAMA,SACA,OACA,WACA,aACA,OAGA,SACA,OACA,aACA,WACA,cACA,SACA,UACA,SACA,QACA,SACA,UACA,OACA,MACA,OACA,eACA,aACA,OACA,UACA,QACA,QACA,QAGA,SACA,aACA,UACA,SACA,WACA,QACA,OAGA,KAGA,aACA,UAGA,UACA,aACA,QACA,UACA,aACA,OACA,OAGA,WACA,QAGYsJ,IAAIrR,EAAM8B,eACtB,OAAOwP,EAAUtR,EAAOA,GAG5B,IAAK,MAAMsB,KAAQ+H,EAAW,CAC1B,MAAM3D,EAAkB,IAAIpC,OAAO,GAAGhC,KAAS,KAE/C,GAAIoE,EAAQE,KAAK5F,GACb,OAAOsR,EAAUtR,EAAME,QAAQwF,EAAU2D,EAAU/H,IAAmBtB,EAE9E,CAEA,IAAK,MAAMsB,KAAQuH,EAAQ,CACvB,MAAMnD,EAAkB,IAAIpC,OAAOhC,EAAM,KAEzC,GAAIoE,EAAQE,KAAK5F,GACb,OAAOsR,EAAUtR,EAAME,QAAQwF,EAAUmD,EAAOvH,IAAmBtB,EAE3E,CAEA,OAAOsR,EAAUtR,EAAOA,EAC5B,CAUA,mBAAOuR,CAAavR,EAAe8I,EAA2B,GAC1D,MAAM0I,EAAkBxR,EAAMyR,MAAM,gBAE9BC,EAAoBF,EAAMG,MAEhC,OAAOH,EAAMpL,KAAK,IAAM9F,KAAKsR,QAAQtR,KAAKuI,OAAO6I,EAAU5I,GAC/D,CAUA,mBAAO+I,CAAa7R,EAAe8I,EAA2B,GAC1D,OAAOxI,KAAKiR,aAAavR,EAAO8I,EACpC,CAaA,eAAOgJ,CAASpS,EAAiB,GAAIqS,GAAmB,EAAM5J,GAAmB,EAAM6J,GAAmB,EAAMC,GAAkB,GAC9H,IAAIH,EAAqB,GACrBI,EAAuC,CAAA,EAEvCH,IACAG,EAAWH,QAAU,CACjB,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAClD,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAClD,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAClD,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAClD,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,MAIvC5J,IACA+J,EAAW/J,QAAU,CACjB,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,MAIjD6J,IACAE,EAAWF,QAAU,CACjB,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAClD,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAAM,IAAK,IAAK,IACnD,IAAK,IAAK,IAAK,MAInBC,IACAC,EAAWD,OAAS,CAAC,MAGzB,IAAK,MAAME,KAAUD,EAAY,CAC7B,MAAMrO,EAAoBqO,EAAWC,GAErCL,EAASM,KAAKvO,EAAQW,KAAKgE,MAAMhE,KAAK6N,SAAWxO,EAAQnE,SAC7D,CAEA,MAAMmE,EAAoByO,OAAOC,OAAOL,GAAYM,OACpD9S,GAAkBoS,EAASpS,OAE3B,IAAK,IAAI+S,EAAY,EAAGA,EAAI/S,EAAQ+S,IAAK,CACrC,MAAMzR,EAAgBwD,KAAKgE,MAAMhE,KAAK6N,SAAWxO,EAAQnE,QAEzDoS,EAASM,KAAKvO,EAAQ7C,GAC1B,CAEA,OAAO8Q,EAASY,SAAS,IAAclO,KAAK6N,SAAW,IAAKlP,OAAO,CAACwP,EAAkBC,IAA4BA,EAAUD,EAAU,GAC1I,CAWA,eAAO/S,CAAS+B,EAAkBT,EAAgB2R,EAAiB,GAC/D,MAAMjT,EAAmB+B,EAASlC,QAAQyB,EAAQsD,KAAKC,IAAIoO,EAAQ,IAEnE,WAAOjT,GAA0BA,CACrC,CASA,aAAOyS,CAAO3S,EAAiB,IAC3B,GAAiC,OAA7BY,KAAKwS,oBACL,OAAOxS,KAAKwS,oBAAoBpT,GAGpC,IAAIqT,EAA6C,EAA1BvO,KAAKkE,KAAK,EAAW,GAExCsK,EAAgBC,OAAOC,gBAAgB,IAAIC,WAAWJ,IAAW3M,KAAK,IAEtEjH,EAAiBiU,KAAKJ,GAE1B,IAAK,MAAM3P,IAAa,CAAC,IAAK,IAAK,KAC/BlE,EAASA,EAAOe,QAAQmD,EAAW,IAGvC,OAAOlE,EAAOW,UAAU,EAAGJ,EAC/B,CASA,+BAAO2T,CAAyBC,EAA+C,MAC3EhT,KAAKwS,oBAAsBQ,CAC/B,CAUA,uCAAOC,CAAiCC,EAAkCC,EAA+B,MACrG,IAAIC,EAAe,EAEnBD,UAAAA,EAAiB/T,IACb,MAAMiU,EAAgCrT,KAAKwS,oBAE3CxS,KAAKwS,oBAAsB,KAE3B,MAAMc,EAAuBtT,KAAK+R,OAAO3S,GAMzC,OAJAY,KAAKwS,oBAAsBa,EAE3BD,IAEOE,IAGXtT,KAAK+S,yBAA0B3T,QACJqJ,IAAnByK,EAASE,GACFF,EAASE,KAGbD,EAAY/T,GAE3B,CAOA,kCAAOmU,GACHvT,KAAKwS,oBAAsB,IAC/B,CAUA,aAAOrL,CAAOtI,EAAgB2U,EAAgB,GAC1C,OAAO3U,EAAOsI,OAAOqM,EACzB,CAWA,mBAAOC,CAAaxU,EAAgBW,EAAmBZ,SACnD,MAAM0U,EAAqB1U,EAAQmS,MAAMlS,GAEzC,IAAIa,EAAiB4T,EAASC,QAE9B,IAAK,MAAM5M,KAAW2M,EAClB5T,GAAUnB,EAAIiV,qBAAWhU,EAAQ+T,uBAAW1U,EAAQA,GAAU8H,EAGlE,OAAOjH,CACX,CAcA,cAAOF,CAAQX,EAA2BW,EAA4BZ,EAA4B6U,GAAyB,WACvH5U,EAAS6B,MAAMC,QAAQ9B,GAAUA,EAAS,CAACA,GAE3C,IAAK,MAAM6U,KAAQ7U,EAAQ,CACvB,MAAMyB,EAAgBzB,EAAOE,QAAQ2U,GAC/BC,EAAmBjT,MAAMC,QAAQ/B,GAAyB,UAAdA,EAAQ0B,UAAM,IAAA+C,EAAAA,EAAI,GAAKzE,EACnEgV,EAAmBlT,MAAMC,QAAQnB,GAAyB,UAAdA,EAAQc,UAAM,IAAAiD,EAAAA,EAAI,GAAK/D,EACnEwF,EAA2ByO,EAAgBC,EAAO,IAAI9Q,OAAO8Q,EAAM,MACnEG,EAAsBF,EAASG,WAAW9O,EAAS4O,GAErDlT,MAAMC,QAAQ/B,GACdA,EAAQ0B,GAASuT,EAEjBjV,EAAUiV,CAElB,CAEA,OAAOjV,CACX,CAWA,mBAAOiG,CAAahG,EAAgBW,EAAiBZ,GACjD,GAAe,KAAXC,EACA,OAAOD,EAKX,OAAiB,IAFMA,EAAQG,QAAQF,GAG5BD,EAAQY,QAAQX,EAAQW,GAG5BZ,CACX,CAWA,mBAAOmV,CAAalV,EAAgBW,EAAiBZ,GACjD,MAAe,KAAXC,EACOD,EAGPgB,KAAKiB,WAAWjC,EAASC,GAClBe,KAAKiF,aAAahG,EAAQW,EAASZ,GAGvCA,CACX,CAWA,kBAAOkG,CAAYjG,EAAgBW,EAAiBZ,GAChD,GAAe,KAAXC,EACA,OAAOD,EAGX,IAAIM,EAAmBN,EAAQO,YAAYN,GAE3C,OAAiB,IAAbK,EACON,EAAQQ,UAAU,EAAGF,GAAYM,EAAUZ,EAAQQ,UAAUF,EAAWL,EAAOG,QAGnFJ,CACX,CAWA,iBAAOoV,CAAWnV,EAAgBW,EAAiBZ,GAC/C,MAAe,KAAXC,EACOD,EAGPgB,KAAKmB,SAASnC,EAASC,GAChBe,KAAKkF,YAAYjG,EAAQW,EAASZ,GAGtCA,CACX,CAYA,qBAAOqV,CAAejP,EAA4BxF,EAA4DZ,EAAiBqH,GAAgB,SAC3I,MAAMhB,EAAqBvE,MAAMC,QAAQqE,GAAWA,EAAU,CAACA,GAE/D,IAAK,MAAMA,KAAWC,EAAU,CAC5B,MAAM3E,EAAgB2E,EAASlG,QAAQiG,GACjCoC,EAAgB,IAAI,IAAIC,IAAI,IAAKrC,EAAQX,WAAWZ,MAAM,cAAgB,GAAK,OAAOiC,KAAK,IAC3F4B,EAAqB,IAAI1E,OAAOoC,EAASoC,GAC/C,IAAIgB,EAAgB,EAEpB,GAAuB,mBAAZ5I,EACPZ,EAAUA,EAAQY,QAAQ8H,EAAY,CAAClI,KAAsB8U,IACrDjO,EAAQ,GAAKmC,EAAQnC,GACrBmC,IAEO5I,EAAQ,CAACJ,EAAW8U,EAAK,MAG7B9U,OAER,CACH,MAAMyU,EAAsBnT,MAAMC,QAAQnB,GAAyB,UAAdA,EAAQc,UAAM,IAAA+C,EAAAA,EAAI,GAAK7D,EAE5EZ,EAAUA,EAAQY,QAAQ8H,EAAa7D,GAC/BwC,EAAQ,GAAKmC,EAAQnC,GACrBmC,IAEOyL,GAGJpQ,EAEf,CACJ,CAEA,OAAO7E,CACX,CAaA,aAAOuV,CAAOtV,EAA2BD,EAA4B6U,GAAyB,GAE1F,OAAO7T,KAAKJ,QAAQX,EAAQ,GAAID,EAAS6U,SAAAA,EAC7C,CASA,cAAOW,CAAQ9U,GACX,OAAOA,EAAMyR,MAAM,IAAIqD,UAAU1O,KAAK,GAC1C,CAUA,YAAOhC,CAAMpE,EAAe+U,GACxB,MAAMC,EAAiBzR,EAAWwR,EAAQ,KAE1C,OAAOA,EAAS/U,EAAME,QAAQ,IAAIoD,OAAO,OAAO0R,MAAY,KAAM,GACtE,CASA,YAAOC,CAAMjV,GACT,OAAOA,EAAM4C,aACjB,CASA,YAAOF,CAAM1C,GACT,OAAOA,EAAMyR,MAAM,aACdxJ,IAAK3G,GAAkC,KAATA,EAAcA,EAAOhB,KAAKsR,QAAQtQ,EAAK,GAAKA,EAAKxB,UAAU,GAAGgC,gBAC5FsE,KAAK,IACd,CASA,eAAO8O,CAASlV,GACZ,IAAIwR,EAAkBxR,EAAMyR,MAAM,KAQlC,OANAD,EAAQA,EAAM9R,OAAS,EACjB8R,EAAMvJ,IAAKkN,GAAyB7U,KAAKoC,MAAMyS,IAC/C7U,KAAK8U,QAAQ5D,EAAMpL,KAAK,MAAM6B,IAAKkN,GAAyB7U,KAAKoC,MAAMyS,IAErD7U,KAAKJ,QAAQ,CAAC,IAAK,IAAK,KAAM,IAAKsR,EAAMpL,KAAK,MAErDqL,MAAM,KAAK4D,OAAOC,SAASlP,KAAK,KAAKS,MAC1D,CAWA,UAAO0O,CAAIvV,GACP,GAAc,KAAVA,EACA,OAAOA,EAGX,MAAMwV,EAA0B,IAAIzN,IAAI,CACpC,MAAO,KAAM,MAAO,MAAO,KAAM,MAAO,KAAM,KAAM,MAAO,IAAK,KAChE,MAAO,KAAM,KAAM,KAAM,KAAM,MAAO,KAAM,MAAO,KAAM,KAAM,QAG7D0N,EAA8B,IAAI1N,IAAI,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,MAEtE,IAAIf,EAAkBhH,EAAMyR,MAAM,OAAO4D,OAAOC,SAEhDtO,EAAM,GAAMA,EAAM,GAAcjG,OAAO,GAAG6B,cAAiBoE,EAAM,GAAcxH,MAAM,GAAGsC,cAExF,IAAK,IAAI2Q,EAAY,EAAGA,EAAIzL,EAAMtH,OAAQ+S,IAAK,CAC3C,IAAIiD,EAAyB1O,EAAMyL,GAAc3Q,cAEjD,GAAI4T,EAAc3T,SAAS,KAAM,CAC7B,IAAI4T,EAA4BD,EAAcjE,MAAM,KAEpDkE,EAAkBA,EAAgB1N,IAAKkN,GAA0BK,EAAWnE,IAAI8D,IAASA,EAAKzV,QAAU,EAAKyV,EAAO7U,KAAKsR,QAAQuD,IAEjInO,EAAMyL,GAAKkD,EAAgBvP,KAAK,IACpC,MAAWoP,EAAWnE,IAAIqE,IAAkBA,EAAchW,QAAU,GAAa,IAAN+S,IAAWgD,EAAepE,IAAKrK,EAAMyL,EAAI,GAAcjT,OAAM,IACpIwH,EAAMyL,GAAKiD,EAEX1O,EAAMyL,GAAKnS,KAAKsR,QAAQ8D,EAEhC,CAEA,OAAO1O,EAAMZ,KAAK,IACtB,CASA,eAAOwP,CAAS5V,GAEZ,MAAM4V,EAAmC,CAErC,gBAAiB,OACjB,WAAiB,SACjB,WAAiB,SACjB,YAAiB,UACjB,UAAiB,QAGjB,uEAAwE,OACxE,UAAwE,OAGxE,WAAwB,OACxB,uBAAwB,OACxB,UAAwB,OACxB,cAAwB,aAGxB,cAAmB,OACnB,kBAAmB,OAGnB,sCAAuC,MAGvC,eAAgB,SAChBC,OAAgB,OAGhB,qBAAsB,MAGtB,aAA2B,MAC3B,cAA2B,OAC3B,0BAA2B,MAC3B,kBAA2B,OAG3B,gCAAiC,OACjC,oBAAiC,OAGjC,wBAAkC,KAClC,iBAAkC,KAClC,aAAkC,KAClC,iCAAkC,KAGlC,cAAe,KAGf,cAAe,SAGf,SAAmB,KACnB,kBAAmB,KAGnB,aAAc,KAGd,WAAY,KAGZ,YAAa,UAGb,SAAe,OACf,cAAe,SACf,UAAe,QACf,UAAe,SACf,WAAe,SACf,WAAe,SAGf,UAAW,QAGXC,MAAS,MAGT,eAAiE,QACjE,gEAAiE,UAGjE,YAAa,SAGb,YAAa,UAGb,cAAe,OACf,UAAe,KAGf,iBAAkB,UAGlB,YAAa,UAGbC,GAAM,IAIJ1M,EAAoC,CAEtC2M,OAAc,QACdC,QAAc,SACdC,OAAc,UACdC,SAAc,WACdC,WAAc,WACdC,QAAc,QACdC,WAAc,YACdC,KAAc,OAGdC,QAAY,WACZC,SAAY,YACZC,MAAY,QACZC,MAAY,OACZC,MAAY,OACZC,QAAY,SACZC,SAAY,UACZC,SAAY,UACZC,QAAY,SAGZC,OAAa,QACbC,MAAa,SACbC,MAAa,OACbC,OAAa,OACbC,SAAa,SACbC,MAAa,OACbC,SAAa,UACbC,SAAa,QACbC,QAAa,SACbC,SAAa,SACbC,KAAa,MACbC,OAAa,SACbC,SAAa,YACbC,UAAa,aACbC,OAAa,QAGbvM,KAAa,OACbwM,MAAa,OACbC,UAAa,YACbC,SAAa,SAGbC,OAAY,OACZC,MAAY,MACZC,SAAY,WACZC,SAAY,WACZC,OAAY,QAGZtM,KAAY,OACZuM,KAAY,QACZC,KAAY,MACZC,KAAY,OACZC,SAAY,UACZC,MAAY,SAGZC,UAAa,WACbC,MAAa,MACbC,OAAa,QACbC,OAAa,QACbC,MAAa,QACbC,SAAa,WACbC,OAAa,QAGbC,OAAe,OACfC,YAAe,eACfC,OAAe,OACfC,MAAe,OACfC,OAAe,QAGfC,OAAU,OAGVC,OAAU,QAGVC,OAAU,QACVC,OAAU,OACVC,OAAU,OACVC,MAAU,OACVC,OAAU,OAGVC,IAAa,MACbC,SAAa,SACbrM,MAAa,QACbsM,MAAa,SACbC,UAAa,aACbC,OAAa,QACbC,UAAa,WACbC,KAAa,QACbC,QAAa,QACbC,MAAa,OACbC,OAAa,SAGbC,QAAY,SACZC,SAAY,WACZC,OAAY,QACZC,QAAY,SACZC,OAAY,UACZC,OAAY,QAGZC,MAAa,QACbC,SAAa,UACbC,UAAa,UACbpM,UAAa,YACbqM,OAAa,OACbC,KAAa,KAGbC,YAAe,cACfC,UAAe,WACfC,QAAe,QACfC,OAAe,SACfC,UAAe,aACfC,SAAe,UAGfC,MAAc,SACd,aAAc,YAGdC,MAAe,OACfC,MAAe,OACfC,QAAe,QACfC,OAAe,OACfpM,OAAe,SACfqM,MAAe,MACfnM,MAAe,QACfoM,QAAe,QACfC,OAAe,QACfC,YAAe,YACf,cAAe,aACflM,QAAe,UACfmM,SAAe,UACfC,QAAe,WACfC,OAAe,UACfjM,MAAe,QACfkM,QAAe,WACfC,UAAe,YAGfC,OAAa,SACbC,OAAa,SACbC,QAAa,QACbC,MAAa,QACbC,UAAa,UACbC,QAAa,SACbC,MAAa,OAGbC,OAAa,QACbC,UAAa,UAGbC,MAAU,OACVC,MAAU,OACVC,OAAU,OAGVC,QAAW,UA0Mf,GAtMiC,IAAItV,IAAI,CAErC,SACA,WACA,UACA,MACA,QAGA,UACA,QACA,WACA,QACA,WACA,WACA,UACA,SAGA,SACA,OACA,SACA,UACA,WACA,WACA,OACA,MACA,SACA,eACA,WACA,cACA,YACA,QACA,SAGA,OACA,SACA,OACA,WACA,QAGA,YACA,QACA,MACA,QACA,YACA,WAGA,UACA,WACA,OACA,WACA,QACA,aACA,OACA,YAGA,UACA,WACA,UACA,aACA,OAGA,eACA,SACA,UACA,WACA,aACA,eAGA,aACA,cACA,UAGA,aACA,QACA,OAGA,MACA,aACA,YACA,WAGA,UACA,OACA,WACA,UAGA,WACA,UACA,aACA,WACA,OACA,QACA,QACA,QACA,QAGA,aACA,OACA,QACA,UACA,YAGA,MACA,YAGA,WACA,YACA,cACA,OACA,UACA,YACA,WACA,SACA,UACA,SACA,SACA,aACA,cACA,WAMA,SACA,OACA,WACA,aACA,OAGA,SACA,OACA,aACA,WACA,cACA,SACA,UACA,SACA,QACA,SACA,UACA,OACA,MACA,OACA,eACA,aACA,OACA,UACA,QACA,QACA,QAGA,SACA,aACA,UACA,SACA,WACA,QACA,OAGA,KAGA,aACA,UAGA,UACA,aACA,QACA,UACA,aACA,OACA,OAGA,WACA,QAGYsJ,IAAIrR,EAAM8B,eACtB,OAAOwP,EAAUtR,EAAOA,GAG5B,IAAK,MAAMsB,KAAQ+H,EAAW,CAC1B,MAAM3D,EAAkB,IA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"}